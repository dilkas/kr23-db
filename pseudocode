COMPILATION

nnfCache (HashMap[Int, List[(CNF, NNFNode)]])
updateCache(CNF, NNFNode): describe in words
Compilation:
* Greedy search using a predefined order. Instead of backtracking, give up.
* 1. add the node, 2. run updateCache(cnf, node), 3. recurse on the remaining theory(/ies), 4. add the edges
* After compilation, run PostOrderVisitor and DomainsVisitor.

tryCache(cnf: CNF)
Preconditions: exists (cnf', nnf) in nnfCache: cnf.hashCode = cnf'.hashCode and identifyRecursion returns something (TODO: reformulate this)
r := identifyRecursion(cnf, cnf')
node := Ref(cnf, r)
updateCache(cnf, node)
V := V + {node}
E := E + {(node, nnf)}

TODO:
Ref()
PostOrderVisitor
DomainsVisitor

==================================================

COUNTING

DomainSizes = Map[Domain, Int] (essentially)
DomainMap = Map[Domain, (Domain, List[(ParametrisedNode, Boolean)])]
Caching is disabled.
Along with domain sizes, we also pass along a  *ParameterMap* = Map[ParametrisedNode, (Int, Int)].
2 node types add info to the ParameterMap: visitConstraintRemoval (maxSize - 1, 1) and visitExists (nbTrue, maxSize - nbTrue).
TODO: describe visitImprovedDomainRecursion.

visitRefNode(Ref, DomainSizes, ParameterMap)
domainSizes.shrink(ref.domainMap, parameterMap)
1. for (domain, size) in domainSizes
1.1. (domain', history) = domainMap[domain] if it's in there or else (domain, emptyset)
1.2. decrement = sum_{(node, complement) in history} parameterMap[node]._2 if complement else ._1
1.3. if decrement > domainSizes[domain'], return 1 (multiplicative unit, base case)
1.4. else, domainSizes'[domain] = domainSizes[domain'] - decrement
2. follow the arrow with domainSizes'
Note: the initial domain name is more like a placeholder than an actual domain