TODO: predicateWeights is also a parameter. It's used when visiting some of the leaf types.

Input: \mathcal{D} - the set of domains featured in the input formula, s - the unique source of the FCG
Data: functionNames = \emptyset
Output: a list of Strings, each defining a function (the top one is the main one)

variableNames <- { d \mapsto newVariableName() | d \in \mathcal{D} }
if (s is a direct successor of a Ref node) {
(expression, functions) <- visit(s, variableNames)
return functions
} else {
f <- newFunctionName(s)
(expression, functions) <- visit(s, variableNames)
return <f(args) = expression> ++ functions, where args = < variableNames(d) | d \in \mathcal{D} >
}

Function visit(node v, variableNames) {
if (v is a direct successor of a Ref node (equivalently, the in-degree of v is greater than 1)) {
f <- newFunctionName(v)
newVariableNames = { if d in v.domains and n contains subtraction then d \mapsto newVariableName() else d \mapsto n | d \mapsto n \in variableNames }
(expression, functions) <- actuallyVisit(v, newVariableNames)
functionCall <- f(<variableNames(d) | d in v.domains>)
functionSignature <- f(<newVariableNames(d) | d in v.domains>)
return (functionCall, <functionSignature = expression> ++ functions)
} else {
actuallyVisit(v, variableNames)
}
}

Function actuallyVisit(node v, variableNames) {
True, Smoothing -> (1, <>)
False -> (0, <>)
Ref_rho(v') -> (functionNames(v')(<variableNames(rho(d)) | d \in v'.domains>), <>) (i.e., a function call)
Or(v', v'') -> {
(expression1, functions1) <- visit(v', variableNames)
(expression2, functions2) <- visit(v'', variableNames)
return ((expression1 + expression2), functions1 ++ functions2)
}
And(v', v'') -> {
(expression1, functions1) <- visit(v', variableNames)
(expression2, functions2) <- visit(v'', variableNames)
return ((expression1 * expression2), functions1 ++ functions2)
}
IDR(v') -> visit(v', variableNames)
Forall(IndependentPartialGrounding)_d -> {
(expression, functions) <- visit(v', variableNames)
return (expression^{variableNames(d)}, functions)
}
Exists(Counting)_d,d1,d2(v') -> {
n <- variableNames(d)
m <- newVariableName()
(expression, functions) <- visit(v', variableNames \cup { d1 \mapsto m, d2 \mapsto (n - m) })
return (\sum_{m=0}^{n} \binom{n}{m} \times expression, functions)
}
ConstraintRemoval_d,d'(v') -> visit(v', variableNames \cup { d' \mapsto (variableNames(d) - 1) })
TODO: instead of talking about skolem functions, just introduce weights in general (based on WmcVisitor)
UnitLeaf_c -> if (c is of the form ({\neg s(v_1, \dots, v_n)}, \emptyset, { v_1 \mapsto D_1, \dots, v_n \mapsto D_n }) for some non-negative integer n, variables v_i and (potentially repeating) domains D_i (AND s is a *Skolem* predicate)
then ((-1)^{\prod_{i=1}^n variableNames(D_i)}, <>)
else (1, <>)
Contradiction_cl:
We assume that:
1. There is only one domain (this restriction can be removed, but I'm not convinced that such a node is ever constructed)
2. All variables are constrained to be unequal to each other.
3. All variables are constrained to be unequal to all constants (if any).
return [c <= variableNames(d) < c + v], where d is the only domain in cl, c is the number of constants in cl, and v is the number of variables in cl
}

for each node v, v.domains is a precomputed set of domains that are used by v and all of its successors (except the ones that are introduced by v or its successors) (this was already part of ForcLift, although had to be reimplemented in a way that avoids infinite loops when dealing with cycles in graphs)

NOTE: for list generators over a set of domains, we assume an arbitrary fixed ordering over all domains

functionNames is a partial map (initially empty) from the set of nodes of the FCG to Strings

newVariableName() just generates a unique identifier for a variable

newFunctionName(node n) does the same thing for function names and also records the new name in functionNames
