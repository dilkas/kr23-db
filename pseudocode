COMPILATION

Compilation:
* Greedy search using a predefined order. Instead of backtracking, give up.
* 1. add the node, 2. run updateCache(cnf, node), 3. recurse on the remaining theory(/ies), 4. add the edges
* After compilation, run PostOrderVisitor and DomainsVisitor.

TODO:
PostOrderVisitor
DomainsVisitor

==================================================

Data: solutions = emptyset
Data: lists of greedy and non-greedy rules
Two stopping conditions: depth & number of solutions

C_0 <- empty cache
(G_0, s_0, C_0, L_0) <- applyGreedyRules(phi, C_0)
if (L_0 is empty) {
  solutions <- solutions u {(G_0, s_0)}
} else {
  q <- Queue((G_0, s_0, C_0, L_0))
  while (!q.empty()) {
    foreach state (G, C, L) in applyNonGreedyRules(q.pop()) {
      if (L is empty) {
        solutions <- solutions cup {G}
      } else {
        q.push((G, C, L))
      }
    }
  }
}

Function applyGreedyRules(phi, C):
foreach greedy rule r {
  S <- r(phi)
  if (S != emptyset) {
    (G, L) <- any element of S
    if (G is null) {
      /* we know that L has just one element */
      return applyGreedyRules(L.head, C)
    } else {
      (V, s, N^+) <- G
      C <- updateCache(C, phi, s)
      return applyGreedyRulesToAllFormulas(G, C, L, s)
    }
  }
  return (null, C, [phi])
}

TODO: should return (G, C, L)

Function applyGreedyRulesToAllFormulas(G, C, L, v):
/** assert: |N^+(v)| = |L| */
N^+(v) <- [pi_1(applyGreedyRules(phi, C)) | phi in L]
return \bigoplus_{phi in L} pi_3(applyGreedyRules(phi, C))

Function updateCache(C, phi, v):
if (#phi not in C)
  return C cup {#phi mapsto (phi, v)}
if (!exists t in C(#phi) s.t. pi_2(t) = v)
  return C cup {#phi mapsto (phi, v) ++ C(#phi)}
return C

/** could be optimised to make fewer copies */
Function applyNonGreedyRules(s):
  (G, C, L) <- s
  phi <- the first element of L
  (G', C', L') <- a copy of s
  states <- []
  foreach non-greedy rule r {
    S <- r(phi)
    foreach (G, L) in S {
      if G is null {
        /** we know that L has just one element */
        states <- states ++ applyNonGreedyRules(G', C', L)
      } else {
        (V, s, N+) <- G
        updateCache(C', phi, s)
        L'' <- applyGreedyRulesToAllFormulas(G, C', L, s)
        if (G' is not null) {
          states <- states ++ (addNode(G', s), C', L'' ++ L'.tail)
        } else {
          states <- states ++ (G, C', L'' ++ L'.tail)
        }
      }
    }
    (G', C', L') <- a copy of s
  }
  return states

Function addNode(G, v, r = s_G):
if (label(r) = Ref) return null
foreach t in N+(r) {
  if t = star {
    update N^+(r) by replacing t with v
    return (V_G cup {v}, s_G, the new N^+)
  }
  G' <- addNode(G, v, t)
  if (G' is not null) return G'
}
return null

applyGreedyRulesToAllFormulas, addNode, and applyNonGreedyRules should take care of graph merging. Take unions of both V and N^+, keeping s the same.

==================================================

COUNTING

DomainSizes = Map[Domain, Int] (essentially)
DomainMap = Map[Domain, (Domain, List[(ParametrisedNode, Boolean)])]
Caching is disabled.
Along with domain sizes, we also pass along a  *ParameterMap* = Map[ParametrisedNode, (Int, Int)].
2 node types add info to the ParameterMap: visitConstraintRemoval (maxSize - 1, 1) and visitExists (nbTrue, maxSize - nbTrue).
TODO: describe visitImprovedDomainRecursion.

visitRefNode(Ref, DomainSizes, ParameterMap)
domainSizes.shrink(ref.domainMap, parameterMap)
1. for (domain, size) in domainSizes
1.1. (domain', history) = domainMap[domain] if it's in there or else (domain, emptyset)
1.2. decrement = sum_{(node, complement) in history} parameterMap[node]._2 if complement else ._1
1.3. if decrement > domainSizes[domain'], return 1 (multiplicative unit, base case)
1.4. else, domainSizes'[domain] = domainSizes[domain'] - decrement
2. follow the arrow with domainSizes'
Note: the initial domain name is more like a placeholder than an actual domain