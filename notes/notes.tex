\documentclass{article}
\usepackage[UKenglish]{babel}
\usepackage[UKenglish]{isodate}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}

\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{mathrsfs}

\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{tikz}
\usepackage[capitalize]{cleveref}

\usetikzlibrary{arrows,fit,positioning,trees,cd}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}

\newcommand\pfun{\mathrel{\ooalign{\hfil$\mapstochar\mkern5mu$\hfil\cr$\to$\cr}}}

\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\Imm}{Im}
\DeclareMathOperator{\Doms}{Doms}
\DeclareMathOperator{\Vars}{Vars}
\DeclareMathOperator{\WMC}{WMC}

\title{Empowering Domain Recursion in Symmetric Weighted First-Order Model Counting}

\begin{document}
\maketitle

\section{Basic Definitions}
 TODO (later): maybe mathcal instead of mathscr

\paragraph{Things I might need to explain.}
\begin{itemize}
\item notation: $\Imm$
\item atom, literal
\item inequality constraint
\item $\Vars$, $\Vars(c) = \Vars(P) \cup \Vars(N) \cup \Vars(C)$
\item $\Doms$ on both formulas and clauses. $\Doms(c) = \Imm \delta_c$, and $\Doms(\phi) = \bigcup_{c \in \phi} \Doms(c)$.
\item the hash codes of clauses and formulas. Introduce the $\#$ notation.
\item substitution
\item size of a domain, how each domain is partitioned into two during compilation.
\item maybe: notation for partial function, notation for powerset, domain size
\item notation for projection (or avoid it?)
\item $\WMC$
\item constraint removal operation
\item two parts: compilation and inference.
\item introduce and use arrows for bijections, injections, set inclusions, etc.
\item $\emptyset$ for an empty partial map.
\end{itemize}

Let $\mathscr{V}$ be the set of circuit nodes.

TODO: maybe $\pi$ is global enough to have a more unique name.

\begin{definition}
  A \emph{domain} is a set with elements not used anywhere else.\footnote{In the context of functions, the domain of a function $f$ retains its usual meaning and is denoted $\dom(f)$.} Let $\mathscr{D}$ be the set of all domains and $\mathscr{C} \subset \mathscr{D}$ be the subset of domains introduced as a consequence of constraint removal. Note that both sets (can) expand during the compilation phase.

Let $\pi\colon \mathscr{D} \pfun \mathscr{D}$ be a partial endomorphism on $\mathscr{D}$ that denotes the \emph{parent} relation, i.e., if $\pi(d) = e$ for some $d, e \in \mathscr{D}$, then we call $e$ the parent (domain) of $d$, and $e$ a child of $d$. Intuitively, $\pi$ arranges all domains into a forest---thus, we often use graph theoretical terminology to describe properties of and relationships between domains.
\end{definition}

\begin{definition}
  A \emph{clause} is a triple $c = (P, N, C, \delta_c)$, where $P$ and $N$ are sets of atoms interpreted as positive and negative literals respectively, $C$ is a set of inequality constraints, and $\delta_c\colon \Vars(c) \to \mathscr{D}$ is a function that maps all variables in $c$ to their domains. Two clauses $c$ and $d = (P', N', C', \delta_d)$ are \emph{isomorphic} (written $c \cong d$) if there is a bijection $\beta\colon \Vars(c) \to \Vars(d)$ such that $c\beta = d\beta$. TODO: we will always use this subscript notation for the $\delta$'s. Equality of clauses is defined in the usual way (i.e., all variables, domains, etc. must match).
\end{definition}

A \emph{formula} is a set of clauses.

\section{Identifying Possibilities for Recursion}

\begin{definition}[Notation]
  For any clause $c = (P, N, C, \delta_c)$, bijection $\beta\colon \Vars(c) \to V$ (for some set of variables $V$) and function $\gamma\colon \Doms(c) \to \mathscr{D}$, let $c \ast (\beta, \gamma) = d$ be the clause with all occurrences of any variable $v \in \Vars(c)$ in $P$, $N$, and $C$ replaced with $\beta(v)$ (so $\Vars(d) = V$) and $\delta_d\colon V \to \mathscr{D}$ defined as $\delta_d \coloneqq \gamma \circ \delta_c \circ \beta^{-1}$. In other words, $\delta_d$ is the unique function that makes the following diagram commute:
  \[
  \begin{tikzcd}
    \Vars(c) \ar[r, tail, two heads, "\beta"] \arrow{d}{\delta_c} & V = \Vars(d) \ar[d, dashed, "\exists!\delta_d"] \\
    \Doms(c) \arrow{r}{\gamma} & \mathscr{D}.
  \end{tikzcd}
  \]
\end{definition}

\begin{algorithm}[t]
  \caption{A recursive function for checking whether one can reuse the circuit for computing $\WMC(\psi)$ to compute $\WMC(\phi)$. Both $\phi$ and $\psi$ are formulas, and $\rho\colon \Doms(\phi) \protect\pfun \Doms(\psi)$ is a partial map.}
  \SetKwProg{Fn}{Function}{:}{}
  \SetKwFunction{identifyRecursion}{identifyRecursion}
  \SetKwFunction{findHistory}{traceAncestors}
  \SetKwFunction{generateMaps}{generateMaps}
  \SetKwFunction{constructDomainMap}{constructDomainMap}
  \SetKwData{suitable}{suitableBijection}
  \SetKwData{found}{foundConstraintRemoval}
  \Fn{\identifyRecursion{$\phi$, $\psi$, $\rho = \emptyset$, $\found = {\normalfont \texttt{false}}$}}{
    \lIf{$|\phi| \ne |\psi|$ {\bf or} $\#\phi \ne \#\psi$}{\Return{\normalfont \texttt{null}}}
    \If{$\phi = \psi = \emptyset$}{
      \lIf{$\found$}{\Return{$\rho$}}
      \Return{\normalfont \texttt{null}}\;
    }
    \ForEach{clause $c \in \phi$}{
      \ForEach{clause $d \in \psi$ such that $\#d = \#c$} {
        \ForEach{$(\beta, \gamma) \in \generateMaps{$c$, $d$, $\rho$}$ such that $c \ast (\beta, \gamma) = d$}{
          $\found' \gets \found$\;
          $\suitable \gets \texttt{true}$\;
          \ForEach{$v \in \Vars(c)$}{
            $\found'' \gets \findHistory{$\delta_c(v)$, $\delta_d(\beta(v))$}$\;
            \If{$\found'' = {\normalfont \texttt{null}}$}{
              $\suitable \gets \texttt{false}$\;
              break\;
            }
            \lIf{$\found''$}{$\found' \gets \texttt{true}$}
          }
          \If{\suitable}{
            $\rho'' \gets \identifyRecursion{$\phi \setminus \{\, c \,\}$, $\psi \setminus \{\, d \,\}$, $\rho \cup \gamma$, $\found'$}$\;
            \lIf{$\rho'' \ne {\normalfont \texttt{null}}$}{\Return{$\rho''$}}
          }
        }
      }
      \Return{\normalfont \texttt{null}}\;
    }
  }
  \Fn{\generateMaps{$c$, $d$, $\rho$}}{
    $M \gets \emptyset$\;
    \ForEach{bijection $\beta\colon \Vars(c) \to \Vars(d)$}{
      \If{$\forall v \in \Vars(c). (\delta_c(v) \not\in {\normalfont \dom}(\rho) \lor \rho(\delta_c(v)) = \delta_d(\beta(v)))$}{
        $\gamma \gets \constructDomainMap{$\Vars(c)$, $\delta_c$, $\delta_d$, $\beta$}$\;
        \lIf{$\gamma \ne {\normalfont \texttt{null}}$}{$M \gets M \cup \{\, (\beta, \gamma) \,\}$}
      }
    }
    \Return{$M$}\;
  }
  \Fn{\constructDomainMap{$V$, $\delta_c$, $\delta_d$, $\beta$}}{
    $\gamma \gets \emptyset$\;
    \ForEach{$v \in V$}{
      \lIf{$\delta_c(v) \not\in \dom(\gamma)$}{$\gamma \gets \gamma \cup \{\, \delta_c(v) \mapsto \delta_d(\beta(v)) \,\}$}
      \lElseIf{$\gamma(\delta_c(v)) \ne \delta_d(\beta(v))$}{\Return{\normalfont \texttt{null}}}
    }
    \Return{$\gamma$}\;
  }
  \Fn{\findHistory{$c$, $d$}}{
    $\found \gets \texttt{false}$\;
    \While{$d \ne c$ {\bf and} $d \in {\normalfont \dom}(\pi)$}{
      \lIf{$d \in \mathscr{C}$}{$\found \gets \texttt{true}$}
      $d \gets \pi(d)$\;
    }
    \lIf{$d = c$}{\Return{\found}}
    \Return{\normalfont \texttt{null}}\;
  }
\end{algorithm}

\begin{figure}[t]
  \centering
  \begin{tikzpicture}[edge from parent/.style={draw,-latex}]
    \node[draw,circle,fill=violet!10] (circuit) {} child {
      node[draw,circle,fill=violet!10] (bmaker) {$\diamondsuit$}
      child {node[draw,circle,fill=violet!10] {}
        child {node[draw,circle,fill=violet!10] {}}
        child {node[draw,circle,fill=violet!10] {}
          child {node[draw,circle,fill=violet!10] {}}
          child {node[draw,circle,fill=violet!10] {}
            child {node[draw,circle,fill=violet!10] {}}
            child {node[draw,circle,fill=violet!10] (amaker) {$\heartsuit$}
              child {node[draw,circle,fill=violet!10] (ref) {}
                child {node[draw,circle,fill=violet!10] {}}
              }
            }
          }
        }
      }
    };
    \node[below right=1cm and 2cm of circuit] (a) {$a$} child {node (aprime) {$a'$}};
    \node[right=1 cm of a] (b) {$b$}
    child {node (btop) {$b^\top$}}
    child {node (bbot) {$b^\bot$}};
    \node[draw,fit=(a) (aprime) (b) (btop) (bbot)] {};
    \draw[-latex] (ref) edge[densely dotted,bend left=90] (circuit);
    \draw[-latex,color=teal] (aprime) edge[densely dashed] node[xshift=2mm,color=teal] {$0$} (amaker);
    \draw[-latex,color=teal] (btop) edge[bend left=50,densely dashed] node[xshift=6mm,color=teal] {$0$} (bmaker);
    \draw[-latex,color=teal] (bbot) edge[bend left=50,densely dashed] node[yshift=-2mm,color=teal] {$1$} (bmaker);
  \end{tikzpicture}
  \caption{A circuit (outside the box) and a forest of domains (inside the box). The dotted line on the left will be added if \texttt{identifyRecursion} returns a non-\texttt{null} mapping. The dashed edges with their labels represent the $\kappa$ function. The circuit nodes with symbols in them are the nodes that introduce new (sub)domains.}
  \label{fig:example}
\end{figure}

The function \texttt{traceAncestors} returns \texttt{null} if domain $c \in \mathscr{D}$ is not an ancestor of domain $d \in \mathscr{D}$. Otherwise, it returns \texttt{true} if the size of $d$ is guaranteed to be strictly smaller than the size of $c$ (i.e., there is domain created by the constraint removal rule on the path from $c$ to $d$) and \texttt{false} if their sizes will be equal at some point during inference.

Notation: For partial functions $\alpha, \beta\colon A \pfun B$ such that $\alpha|_{\dom(\alpha) \cap \dom(\beta)} = \beta|_{\dom(\alpha) \cap \dom(\beta)}$, we write $\alpha \cup \beta$ for the unique partial function such that $\alpha \cup \beta|_{\dom(\alpha)} = \alpha$, and $\alpha \cup \beta|_{\dom(\beta)} = \beta$.

TODO: explain why $\rho \cup \gamma$ is possible.

TODO: explain what the second return statement is about and why a third one is not necessary.

TODO: mention which one is the main function, what each function takes and returns.

\begin{example}
  % TODO: explain how the algorithm establishes a recursive relationship from
  % 1. formulas (both the Forclift representation and the more normal way to write down the same thing)
  % 2. definitions of delta_c, delta_d, kappa, pi
  \begin{align*}
    \forall X \in a'. \forall Y \in b^\bot. \forall Z \in b^\bot. Z \ne Y &\implies \neg p(X, Y) \lor \neg p(X, Z) \\
    \forall X \in a'. \forall Y \in b^\bot. \forall Z \in a'. X \ne Z &\implies \neg p(X, Y) \lor \neg p(Z, Y)
  \end{align*}
  to
  \begin{align*}
    \forall X \in a. \forall Y \in b. \forall Z \in b. Y \ne Z &\implies \neg p(X, Y) \lor \neg p(X, Z) \\
    \forall X \in a. \forall Y \in b. \forall Z \in a. X \ne Z &\implies \neg p(X, Y) \lor \neg p(Z, Y)
  \end{align*}
  and mention \cref{fig:example}. Solution map (stored as the edge label):
  \begin{align*}
    \rho(a') &= (a, \{\, (\diamondsuit, 0) \,\}) \\
    \rho(b^\bot) &= (b, \{\, (\heartsuit, 1) \,\})
  \end{align*}
\end{example}

TODO: conclude with a description of the inference rule and the node/edge type.

\section{New Node Types}

\subsection{Improved Domain Recursion}

The original version of domain recursion is here \cite{DBLP:conf/nips/Broeck11}.

\subsection{Constraint Removal}

\section{Other Topics}

\begin{itemize}
\item domains, smoothing, and avoiding infinite cycles
\item new rules that don't create nodes (e.g., duplicate removal, unconditional contradiction detection, etc.)
\end{itemize}

\section{Circuit Evaluation}

TODO: new node types, their algebraic/graphical representation, what info they hold, and how they're created.

TODO: describe evaluation of: and, counting, constraint removal, ref, unit, contradiction, improved domain recursion. Most of this will be from \cite{DBLP:conf/ijcai/BroeckTMDR11}.

\bibliographystyle{acm}
\bibliography{notes}

\end{document}
