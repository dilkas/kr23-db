\documentclass{article}
\pdfpagewidth=8.5in
\pdfpageheight=11in

\usepackage{kr}

% Use the postscript times font!
\usepackage{times}
\usepackage{soul}
\usepackage{url}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[small]{caption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{booktabs}
% \usepackage{algorithm}
% \usepackage{algorithmic}
\urlstyle{same}

\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{pifont}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{tikz}
\usepackage[capitalize]{cleveref}
\usepackage{multirow}
\usepackage{colortbl}
\usepackage{complexity}
\usepackage{siunitx}
\usepackage{forest}
\usepackage[inline]{enumitem}
\usepackage{xr}
\externaldocument{paper}

\usetikzlibrary{cd}
\usetikzlibrary{shapes}

% the following package is optional:
%\usepackage{latexsym}

% See https://www.overleaf.com/learn/latex/theorems_and_proofs
% for a nice explanation of how to define new theorems, but keep
% in mind that the amsthm package is already included in this
% template and that you must *not* alter the styling.
% \newtheorem{example}{Example}
\newtheorem{theorem}{Theorem}
\newtheorem{fact}{Fact}
\newtheorem{proposition}{Proposition}
\newtheorem{conjecture}{Conjecture}
\newtheorem{claim}{Claim}[theorem]
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}

\pdfinfo{
/TemplateVersion (KR.2022.0, KR.2023.0)
}

\crefalias{diagram}{equation}
\crefname{diagram}{diagram}{diagrams}
\Crefname{diagram}{Diagram}{Diagrams}
\creflabelformat{diagram}{#2\textup{(#1)}#3}

\crefname{algocf}{Algorithm}{Algorithms}
\Crefname{algocf}{Algorithm}{Algorithms}
\crefname{condition}{Condition}{Conditions}
\Crefname{condition}{Condition}{Conditions}

\newcommand{\crefrangeconjunction}{--}
\newcommand\pfun{\mathrel{\ooalign{\hfil$\mapstochar\mkern5mu$\hfil\cr$\to$\cr}}}
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\newcommand{\FOtwo}{$\mathsf{FO}^{2}$}
\newcommand{\FOthree}{$\mathsf{FO}^{3}$}
\newcommand{\SFO}{$\mathsf{S}^{2}\mathsf{FO}^{2}$}
\newcommand{\SRU}{$\mathsf{S}^{2}\mathsf{RU}$}
\newcommand{\Uone}{$\mathsf{U}_{1}$}
\newcommand{\Ctwo}{$\mathsf{C}^{2}$}
\newcommand{\IFO}{$\mathsf{I}\mathsf{FO}^{2}$}

\DeclareMathOperator{\friends}{\texttt{friends}}
\DeclareMathOperator{\smokes}{\texttt{smokes}}
\DeclareMathOperator{\CR}{\textsc{CR}}
\DeclareMathOperator{\GDR}{\textsc{GDR}}
\DeclareMathOperator{\Reff}{\textsc{Ref}}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\Doms}{Doms}
\DeclareMathOperator{\Vars}{Vars}
\DeclareMathOperator{\Preds}{Preds}
\SetKwProg{Fn}{Function}{:}{}
\SetKwFunction{identifyRecursion}{r}
\SetKwFunction{generateMaps}{genMaps}

\makeatletter
\newcommand{\nosemic}{\renewcommand{\@endalgocfline}{\relax}}% Drop semi-colon ;
\newcommand{\dosemic}{\renewcommand{\@endalgocfline}{\algocf@endline}}% Reinstate semi-colon ;
\newcommand{\pushline}{\Indp}% Indent
\newcommand{\popline}{\Indm\dosemic}% Undent
\makeatother
\Crefname{algocf}{Algorithm}{Algorithms}
\crefname{line}{line}{lines}

\forestset{
sn edges/.style={for tree={edge={-Latex}}}
}

\begin{document}

\appendix

\section{Proofs}

TODO: finish arranging the definitions

We begin with a few definitions that formalise the notion of a model.

For any set $S$, let $2^{S}$ denote its power set and
$S^{\ast} \coloneqq \bigcup_{i=0}^{\infty} S^{i}$ the set of tuples of any
finite length of elements of $S$. For example,
$\{\,a, b\,\}^{\ast} = \{\, (), (a), (b), (a, a), \dots \,\}$.

Let $\Preds$ be the function that maps any clause or formula to the set of
predicates used within.

For any $n \in \mathbb{N}_{0}$, let $[n] \coloneqq \{\, 1, \dots, n \,\}$, e.g.,
$[0] = \emptyset$, and $[2] = \{\, 1, 2 \,\}$.

Each formula $\phi$ has a map
$\pi_{\phi}\colon \Preds(\phi) \to {\Doms(\phi)}^{\ast}$ s.t., for each
predicate $\texttt{p}/n \in \Preds(\phi)$, we have that
$\pi_{\phi}(\texttt{p}) \in {\Doms(\phi)}^{n}$.

\begin{definition}\label{def:model}
  Let $\phi$ be a formula and $\sigma$ a domain size function. A \emph{model} of
  $(\phi, \sigma)$ is a map
  $\mathfrak{M}\colon \Preds(\phi) \to 2^{\mathbb{N}_{0}^{\ast}}$ s.t.\ the
  following two conditions are satisfied.
  \begin{enumerate}
    \item Let $\texttt{p}/n \in \Preds(\phi)$ be a predicate and let
          $\pi_{\phi}(\texttt{p}) = {(d_{i})}_{i=1}^{n}$ for some domains
          $d_{i} \in \Doms(\phi)$. Then
          \begin{equation}\label{eq:subset}
            \mathfrak{M}(\texttt{p}) \subseteq \prod_{i=1}^{n}[\sigma(d_{i})].\footnote{For simplicity, \cref{def:model} ignores constants. To include constants, one would replace $[\sigma(d_{i})]$ with a set that contains all constants associated with domain $d_{i}$, extended with enough new elements to make its cardinality $\sigma(d_{i})$.}
          \end{equation}
    \item As a collection of relations, $\mathfrak{M}$ satisfies $\phi$.
    \begin{itemize}
      \item TODO: introduce the substitution for formulas, moving the definition from elsewhere
      \item define inductively as...
      \item (not exhaustive)
      \item $\mathfrak{M} \models \phi \land \psi$ iff $\mathfrak{M} \models \phi$ and $\mathfrak{M} \models \psi$
      \item $\mathfrak{M} \models \phi \lor \psi$ iff $\mathfrak{M} \models \phi$ or $\mathfrak{M} \models \psi$
      \item $\mathfrak{M} \models \neg\phi$ iff $\mathfrak{M} \not\models \phi$
      \item $\mathfrak{M} \models (\forall X \in \Delta\text{. }\phi)$ iff $\mathfrak{M} \models \phi[x/\{\, X \,\}]$ for all $x \in \Delta$
      \item One can then add inequality constraints to the semantics as follows
      \item $\mathfrak{M} \models (\forall X \in \Delta\text{. } X \ne c \Rightarrow \phi)$ iff $\mathfrak{M} \models \phi[x/\{\, X \,\}]$ for all $x \in \Delta \setminus \{\, c \,\}$
      \item $\mathfrak{M} \models (\forall X,Y \in \Delta\text{. } X \ne Y \Rightarrow \phi)$ iff $\mathfrak{M} \models \phi[x/\{\, X \,\}][y/\{\, Y \,\}]$ for all $x,y \in \Delta$ s.t. $x \ne y$
    \end{itemize}
  \end{enumerate}
\end{definition}

\begin{theorem}[Correctness of $\GDR$]
  Let $\phi$ be the formula used as input to \cref{alg:domainrecursion},
  $\Omega \in \mathcal{D}$ the domain selected on \cref{line:condition}, and
  $\phi'$ the formula constructed by the algorithm for $\Omega$. Suppose that
  $\Omega \ne \emptyset$. Then $\phi \equiv \phi'$.
\end{theorem}
\begin{proof}
  Let $x$ be the constant introduced on \cref{line:constant} and $c$ a clause of
  $\phi$ selected on \cref{line:forclause} of the algorithm. We will show that
  $c$ is equivalent to the conjunction of clauses added to $\phi'$ on
  \cref{line:conditions,line:generation}.

  If $c$ has no variables with domain $\Omega$, then
  \cref{line:conditions,line:generation} simply add a copy of $c$ to $\phi'$. If
  $c$ has one variable with domain $\Omega$, say, $X$, then
  $c \equiv \forall X \in \Omega\text{. } \psi$ for some formula $\psi$ with one
  free variable $X$. In this case, \cref{line:conditions,line:generation} create
  two clauses: $\psi[x/\{\, X \,\}]$ and $\forall X \in \Omega\text{.
  } X \ne x \Rightarrow \psi$. It is easy to see that their conjunction is
  equivalent to $c$ provided that $\Omega \ne \emptyset$ and so $x$ is a
  well-defined constant.

  Let $V$ be the set of variables introduced on \cref{line:V}. It remains to
  show that repeating the transformation
  \[
    \forall X \in \Omega\text{. } \psi \mapsto \{\, \psi[x/\{\, X \,\}], \forall X \in \Omega\text{. } X \ne x \Rightarrow \psi \,\}
  \]
  for all variables $X \in V$ produces the same clauses as
  \cref{line:conditions,line:generation} (except for some tautologies that the
  latter method skips). Note that the order in which these operations are
  applied is immaterial. In other words, if we add inequality constraints for
  variables ${\{\, X_{i} \,\}}_{i=1}^{n}$, and apply substitution for variables
  $V \setminus {\{\, X_{i} \,\}}_{i=1}^{n}$, then---regardless of the order of
  operations---we get
  \[
    \forall X_{1}, \dots, X_{n} \in \Omega\text{.} \bigwedge_{i=1}^{n} X_{i} \ne x \Rightarrow \psi\left[x / \left(V \setminus {\{\, X_{i} \,\}}_{i=1}^{n}\right)\right].
  \]
  This formula is equivalent to the clause generated on \cref{line:generation}
  with $W = V \setminus {\{\, X_{i} \,\}}_{i=1}^{n}$. Thus, for every clause $c$
  of $\phi$, the new formula $\phi'$ gets a set of clauses whose conjunction is
  equivalent to $c$. Hence, the two formulas are equivalent.
\end{proof}

\begin{theorem}[Correctness of $\CR$]
  Let $\phi$ be the input formula of \cref{alg:constraintremoval}, $(\Omega, x)$
  a replaceable pair, and $\phi'$ the formula constructed by the algorithm, when
  $(\Omega, x)$ is selected on \cref{line:crconditions}. Then
  $\phi \equiv \phi'$, where the domain $\Omega'$ introduced on
  \cref{line:newdomain} is interpreted as $\Omega \setminus \{\, x \,\}$.
\end{theorem}
\begin{proof}
  Since there is a natural bijection between the clauses of $\phi$ and $\phi'$,
  we shall argue about the equivalence of each pair of clauses. Let $c$ be an
  arbitrary clause of $\phi$ and $c'$ its corresponding clause of $\phi'$.

  If $c$ has no variables with domain $\Omega$, then it cannot have any
  constraints involving $x$, so $c' = c$. Otherwise, for notational simplicity,
  let us assume that $X$ is the only variable in $c$ with domain $\Omega$ (the
  proof for an arbitrary number of variables is virtually the same). By
  \cref{def:replaceable}, we can rewrite $c$ as $\forall X \in \Omega\text{.
  } X \ne x \Rightarrow \psi$, where $\psi$ is a formula with $X$ as the only free
  variable and with no mention of either $x$ or $\Omega$. Then
  $c' \equiv \forall X \in \Omega'\text{. } \psi$. Since
  $\Omega' \coloneqq \Omega \setminus \{\, x \,\}$, we have that $c \equiv c'$.
  Since $c$ was an arbitrary clause of $\phi$, this completes the proof that
  $\phi \equiv \phi'$.
\end{proof}

\begin{theorem}[Correctness of $\Reff$]
  Let $\phi$ be the formula used as input to \cref{alg:trycache}. Let $\psi$ be
  any formula selected on \cref{line:selectformula} of the algorithm s.t.\
  $\rho \ne {\normalfont\texttt{null}}$ on \cref{line:rho}. Let $\sigma$ be a
  domain size function. Then the set of models of $(\psi, \sigma \circ \rho)$ is
  equal to the set of models of $(\phi, \sigma)$.
\end{theorem}
\begin{proof}
  We first show that the right-hand side of \cref{eq:subset} is the same for
  models of both $(\phi, \sigma)$ and $(\psi, \sigma \circ \rho)$.
  \Cref{alg:trycache} ensures that $\psi \equiv \phi$ up to domains. In
  particular, this means that $\Preds(\psi) = \Preds(\phi)$. The square in
  \begin{equation}\label[diagram]{diagram:ref}
    \begin{tikzcd}
      \Preds(\psi) \ar[equal]{r} \ar[d, swap, "\pi_{\psi}"] & \Preds(\phi) \ar[d, "\pi_{\phi}"] \\
      {\Doms(\psi)}^{\ast} \ar[r, "\rho"] & {\Doms(\phi)}^{\ast} \ar[r, "\sigma"] & \mathbb{N}_{0}^{\ast}
    \end{tikzcd}
  \end{equation}
  commutes by \cref{def:formula} and the definition of $\rho$. In other words,
  for any predicate $\texttt{p}/n \in \Preds(\psi) = \Preds(\phi)$, function
  $\rho$ translates the domains associated with $\texttt{p}$ in $\psi$ to the
  domains associated with $\texttt{p}$ in $\phi$. Let
  $\pi_{\phi}(\texttt{p}) = {(d_{i})}_{i=1}^{n}$ and
  $\pi_{\psi}(\texttt{p}) = {(e_{i})}_{i=1}^{n}$ for some domains
  $d_{i} \in \Doms(\phi)$ and $e_{i} \in \Doms(\psi)$. Since
  $\rho(e_{i}) = d_{i}$ for all $i = 1, \dots, n$ by the commutativity in
  \cref{diagram:ref}, we get that
  \begin{equation}\label{eq:equality}
    \prod_{i=1}^{n}[\sigma(d_{i})] = \prod_{i=1}^{n}[\sigma \circ \rho(e_{i})]
  \end{equation}
  as required. Certainly, any subset of the left-hand side of \cref{eq:equality}
  (e.g., $\mathfrak{M}(\texttt{p})$, where $\mathfrak{M}$ is a model of
  $(\phi, \sigma)$) is a subset of the right-hand side and vice versa. Since
  $\phi$ and $\psi$ semantically only differ in what domains they refer to,
  every model of $\phi$ satisfies $\psi$ and vice versa, completing the proof.
\end{proof}

\section{Solutions Found by \textsc{Crane}}

Here we list the exact function definitions produced by \textsc{Crane} for all
of the problem instances in Section~6 both before and after algebraic
simplification (excluding multiplications by one). The correctness of all of
them has been checked by identifying suitable base cases and verifying the
numerical answers across a range of domain sizes.

\begin{enumerate}
  \item $\Theta(m)$ solution for counting $\Gamma \to \Gamma$ functions:
  \[
    f(m) = {\left(-1 + \sum_{l=0}^{m} \binom{m}{l} [l < 2]\right)}^{m} = m^{m}.
  \]
  \item $\Theta(m^3 + n^3)$ solution for counting $\Gamma \to \Delta$
  surjections:
  \begin{align*}
    f(m, n) ={}& \sum_{l=0}^{m} \binom{m}{l}{(-1)}^{m-l} \sum_{k=0}^{n} \binom{n}{k} {(-1)}^{n-k}\\
               &{\left( \sum_{j=0}^{k} \binom{k}{j} [j < 2] \right)}^{l} \\
    ={}& \sum_{l=0}^{m} \binom{m}{l}{(-1)}^{m-l} \sum_{k=0}^{n} \binom{n}{k} {(-1)}^{n-k} {(k+1)}^{l}.
  \end{align*}
  \item $\Theta(m^{3})$ solution for counting $\Gamma \to \Gamma$ surjections:
  \begin{align*}
    f(m) ={}& \sum_{l=0}^{m} \binom{m}{l}{(-1)}^{m-l} \sum_{k=0}^{m} \binom{m}{k} {(-1)}^{m-k}\\
            &{\left( \sum_{j=0}^{k} \binom{k}{j} [j < 2] \right)}^{l} \\
    ={}& \sum_{l=0}^{m} \binom{m}{l}{(-1)}^{m-l} \sum_{k=0}^{m} \binom{m}{k} {(-1)}^{m-k} {(k+1)}^{l}.
  \end{align*}
  \item $\Theta(mn)$ solution for counting $\Gamma \to \Delta$ injections and
  partial injections (with different base cases):
  \begin{align*}
    f(m, n) ={}& \sum_{l=0}^m \binom{m}{l} [l<2] f(m-l, n-1)\\
    ={}& f(m, n-1) + mf(m-1, n-1).
  \end{align*}
  \item $\Theta(m^{3})$ solution for counting $\Gamma \to \Gamma$ injections:
  \begin{align*}
    f(m) ={}& \sum_{l=0}^{m} \binom{m}{l} {(-1)}^{m-l} g(m, l); \\
    g(m, l) ={}& \sum_{k=0}^{l} \binom{l}{k} [k < 2] g(m - 1, l - k)\\
    ={}& g(m - 1, l) + lg(m - 1, l - 1).
  \end{align*}
  % \item $\Theta(m^{2})$ solution for counting $\Gamma \to \Gamma$ partial
  %       injections:
  % \begin{align*}
  %   f(m) ={}& f(m - 1) + \sum_{l = 0}^{m} \binom{m}{l} \sum_{k = 0}^{m} \binom{m}{k}\\
  %           &[1 \le l < 3] [k < 2] 2^{m - l} g(m - l, m - k - 1)\\
  %   ={}& f(m - 1) + m2^{m-1}g(m-1, m-1)\\
  %   +{}& m^{2}2^{m-1}g(m-1, m-2)\\
  %   +{}& \binom{m}{2}2^{m-2}g(m-2, m-1) \\
  %   +{}& \binom{m}{2}m2^{m-2}g(m-2, m-2)\\
  %   g(i, j) ={}& \sum_{h = 0}^{j} \binom{j}{h} [h < 2] g(i - 1, j - h)\\
  %   ={}& g(i-1, j) + jg(i-1, j-1).
  %   \end{align*}
  \item $\Theta(m)$ solution for counting $\Gamma \to \Delta$ bijections:
  \[
    f(m, n) = mf(m-1, n-1).
  \]
\end{enumerate}

\end{document}
