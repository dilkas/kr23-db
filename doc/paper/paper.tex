\documentclass{article}
\pdfpagewidth=8.5in
\pdfpageheight=11in

\usepackage{kr}

% Use the postscript times font!
\usepackage{times}
\usepackage{soul}
\usepackage{url}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[small]{caption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{booktabs}
% \usepackage{algorithm}
% \usepackage{algorithmic}
\urlstyle{same}

\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{pifont}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{tikz}
\usepackage[capitalize]{cleveref}
\usepackage{multirow}
\usepackage{colortbl}
\usepackage{complexity}
\usepackage{siunitx}
\usepackage{forest}
\usepackage[inline]{enumitem}

\usetikzlibrary{cd}
\usetikzlibrary{shapes}

% the following package is optional:
%\usepackage{latexsym}

% See https://www.overleaf.com/learn/latex/theorems_and_proofs
% for a nice explanation of how to define new theorems, but keep
% in mind that the amsthm package is already included in this
% template and that you must *not* alter the styling.
% \newtheorem{example}{Example}
\newtheorem{theorem}{Theorem}
\newtheorem{fact}{Fact}
\newtheorem{proposition}{Proposition}
\newtheorem{conjecture}{Conjecture}
\newtheorem{claim}{Claim}[theorem]
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\pdfinfo{
/TemplateVersion (KR.2022.0, KR.2023.0)
}

\title{Synthesising Recursive Functions for First-Order Model Counting:\\
  Challenges, Progress, and Conjectures}

% TODO (at the very end)
% grammarly the whole thing
% read the formatting instructions and their LaTeX source (email font?)
% make sure there are no overflow errors
% make sure the result table (as well as other floating objects) are on the right pages

\author{%
Paulius Dilkas$^1$\and
Vaishak Belle$^2$\\
\affiliations
$^1$National University of Singapore, Singapore, Singapore\\
$^2$University of Edinburgh, Edinburgh, UK\\
\emails
paulius.dilkas@nus.edu.sg,
vbelle@ed.ac.uk
}

\crefname{algocf}{Algorithm}{Algorithms}
\Crefname{algocf}{Algorithm}{Algorithms}
\crefname{condition}{Condition}{Conditions}
\Crefname{condition}{Condition}{Conditions}
\crefname{line}{line}{lines}

\crefalias{diagram}{equation}
\crefname{diagram}{Diagram}{Diagrams}
\Crefname{diagram}{Diagram}{Diagrams}
\creflabelformat{diagram}{#2\textup{(#1)}#3}

\crefalias{formula}{equation}
\crefname{formula}{Formula}{Formulas}
\Crefname{formula}{Formula}{Formulas}
\creflabelformat{formula}{#2\textup{(#1)}#3}

\newcommand{\crefrangeconjunction}{--}
\newcommand\pfun{\mathrel{\ooalign{\hfil$\mapstochar\mkern5mu$\hfil\cr$\to$\cr}}}
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\newcommand{\FOtwo}{$\mathsf{FO}^{2}$}
\newcommand{\FOthree}{$\mathsf{FO}^{3}$}
\newcommand{\SFO}{$\mathsf{S}^{2}\mathsf{FO}^{2}$}
\newcommand{\SRU}{$\mathsf{S}^{2}\mathsf{RU}$}
\newcommand{\Uone}{$\mathsf{U}_{1}$}
\newcommand{\Ctwo}{$\mathsf{C}^{2}$}
\newcommand{\IFO}{$\mathsf{I}\mathsf{FO}^{2}$}
\newcommand\mdoubleplus{\mathbin{+\mkern-10mu+}}
\newcommand{\Done}{\mathsf{D}_{1}}
\newcommand{\Dtwo}{\mathsf{D}_{2}}
\newcommand{\Dthree}{\mathsf{D}_{3}}

\DeclareMathOperator{\friends}{\texttt{friends}}
\DeclareMathOperator{\smokes}{\texttt{smokes}}
\DeclareMathOperator{\CR}{\textsc{CR}}
\DeclareMathOperator{\GDR}{\textsc{GDR}}
\DeclareMathOperator{\Reff}{\textsc{Ref}}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\Doms}{Doms}
\DeclareMathOperator{\Vars}{Vars}
\DeclareMathOperator{\Preds}{Preds}
\SetKwProg{Fn}{Function}{:}{}
\SetKwFunction{identifyRecursion}{r}
\SetKwFunction{generateMaps}{genMaps}

\makeatletter
\newcommand{\nosemic}{\renewcommand{\@endalgocfline}{\relax}}% Drop semi-colon ;
\newcommand{\dosemic}{\renewcommand{\@endalgocfline}{\algocf@endline}}% Reinstate semi-colon ;
\newcommand{\pushline}{\Indp}% Indent
\newcommand{\popline}{\Indm\dosemic}% Undent
\makeatother

\forestset{
sn edges/.style={for tree={edge={-Latex}}}
}

\hyphenation{ForcLift}
\hyphenation{Crane}
\hyphenation{Alchemy}
\hyphenation{FastWFOMC}
\hyphenation{Magician}
\hyphenation{Tuffy}

\begin{document}

\maketitle

\begin{abstract}
  First-order model counting (FOMC) is a computational problem that asks to
  count the models of a sentence in finite-domain first-order logic. In this
  paper, we argue that the capabilities of FOMC algorithms to date are limited
  by their inability to express many types of recursive computations. To enable
  such computations, we relax the restrictions that typically accompany domain
  recursion and generalise the circuits used to express a solution to an FOMC
  problem to directed graphs that may contain cycles. To this end, we adapt the
  most well-established (weighted) FOMC algorithm \textsc{ForcLift} to work with
  such graphs and introduce new compilation rules that can create cycle-inducing
  edges that encode recursive function calls. These improvements allow the
  algorithm to find efficient solutions to counting problems that were
  previously beyond its reach, including those that cannot be solved efficiently
  by any other exact FOMC algorithm. We end with a few conjectures on what
  classes of instances could be domain-liftable as a result.
\end{abstract}

% KEYWORDS:
% model counting
% first-order logic
% recursion
% knowledge compilation

% TOPICS:
% KR & ML: probabilistic reasoning and learning
% KR & ML: statistical relational learning
% (no) computational aspects of knowledge representation
% (no) knowledge representation languages
% (no) KR & ML: graphical models for knowledge representation and reasoning

\section{Introduction}\label{sec:introduction}

% TODO: add a flow graph: \phi -> Box (Compilation) -> \G_\phi -> Box (Algorithm
% 4) -> \mathcal{F}_\phi -> Box (simplification) -> \mathcal{F|_\phi, base
% cases, domain sizes -> Box (Propagation (?))

% TODO: what's the punchline? make sure the introduction tells the reader what
% to expect from section 5

% TODO: (everywhere in the paper): emphasise that the experimental results show
% Crane to be strictly more capable than ForcLift in a sense that it can solve
% everything that ForcLift can and more (including instances beyond C^2).

% 1. What is the problem?
% 2. Why is it interesting and important?

\emph{First-order model counting} (FOMC) is the problem of computing the number
of models of a sentence in first-order logic given the size(s) of its
domain(s)~\cite{DBLP:conf/pods/BeameBGS15}. \emph{Symmetric weighted FOMC}
(WFOMC) extends FOMC with (pairs of) weights on predicates and asks for a
weighted sum across all models instead. By fixing the sizes of the domains, a
WFOMC instance can be rewritten as an instance of (propositional) weighted model
counting~\cite{DBLP:journals/ai/ChaviraD08}. WFOMC emerged as the dominant
approach to \emph{lifted (probabilistic) inference}. Lifted inference techniques
exploit symmetries in probabilistic models by reasoning about sets rather than
individuals~\cite{DBLP:conf/ecai/Kersting12}. By doing so, many instances become
solvable in polynomial time~\cite{DBLP:conf/nips/Broeck11}. The development of
lifted inference algorithms coincided with work on probabilistic relational
models that combine the syntactic power of first-order logic with probabilistic
models such as Bayesian and Markov networks, allowing for a more relational view
of uncertainty
modelling~\cite{DBLP:series/synthesis/2016Raedt,DBLP:journals/ml/KimmigMG15,DBLP:journals/ml/RichardsonD06}.
Lifted inference techniques for probabilistic databases, while developed
somewhat independently, have also been inspired by
WFOMC~\cite{DBLP:journals/pvldb/GatterbauerS15,DBLP:journals/debu/GribkoffSB14}.
While WFOMC has received more attention in the literature, FOMC is an
interesting problem in an of itself because of its connections to finite model
theory~\cite{DBLP:conf/kr/BremenK21} and applications in enumerative
combinatorics~\cite{DBLP:conf/ilp/BarvinekB0ZK21,DBLP:journals/corr/abs-2302-04606}.
There is also a recent line of work that uses FOMC-based methods to count
solutions to constraint satisfaction
problems~\cite{DBLP:journals/jair/TotisDRK23}.

% Lifted inference algorithms are typically used on probabilistic models such as
% probabilistic programming
% languages~\cite{DBLP:journals/ml/RaedtK15,DBLP:journals/ijar/RiguzziBZCL17},
% Markov logic
% networks~\cite{DBLP:conf/ijcai/BroeckTMDR11,DBLP:journals/cacm/GogateD16}.

% 3. Why is it hard? (E.g., why do naive approaches fail?)
% complexity/liftability -> murky boundary

Traditionally in computational complexity theory, a problem is \emph{tractable}
if it can be solved in time polynomial in the instance size. The equivalent
notion in (W)FOMC is liftability. A (W)FOMC instance is \emph{(domain-)liftable}
if it can be solved in time polynomial in the size(s) of the
domain(s)~\cite{DBLP:conf/starai/JaegerB12}. Over more than a decade, many
classes of instances were shown to be liftable. First, Van den
Broeck~\shortcite{DBLP:conf/nips/Broeck11} showed that the class of all
sentences of first-order logic with up to two variables (denoted \FOtwo{}) is
liftable. Then Beame et al.~\shortcite{DBLP:conf/pods/BeameBGS15} proved that
there exists a sentence with three variables for which FOMC is
$\#\P_{1}$-complete (i.e., \FOthree{} is not liftable). Since these two seminal
results, most of the research on (W)FOMC focused on developing faster solutions
for the \FOtwo{}
fragment~\cite{DBLP:conf/uai/BremenK21,DBLP:conf/aaai/MalhotraS22} and defining
new liftable fragments. These fragments include \SFO{} and
\SRU{}~\cite{DBLP:conf/nips/KazemiKBP16},
\Uone{}~\cite{DBLP:conf/lics/KuusistoL18}, \Ctwo{} (i.e., the two-variable
fragment with counting
quantifiers)~\cite{DBLP:journals/jair/Kuzelka21,DBLP:conf/aaai/MalhotraS22}, and
\Ctwo{} extended with axioms describing trees~\cite{DBLP:conf/kr/BremenK21},
directed acyclic graphs~\cite{DBLP:journals/corr/abs-2302-09830}, and linear
order~\cite{DBLP:journals/corr/abs-2211-01164}. On the empirical front, there
are several implementations of exact WFOMC algorithms:
\textsc{Alchemy}~\cite{DBLP:journals/cacm/GogateD16},
\textsc{FastWFOMC}~\cite{DBLP:conf/uai/BremenK21},
\textsc{ForcLift}~\cite{DBLP:conf/ijcai/BroeckTMDR11}, and
\textsc{L2C}~\cite{DBLP:conf/kr/KazemiP16}. Approximate counting is supported by
\textsc{Alchemy}, \textsc{ApproxWFOMC}~\cite{DBLP:conf/ijcai/BremenK20},
\textsc{ForcLift}~\cite{DBLP:conf/uai/BroeckCD12},
\textsc{Magician}~\cite{DBLP:conf/aaai/VenugopalSG15}, and
\textsc{Tuffy}~\cite{DBLP:journals/pvldb/NiuRDS11}.

% 4. Why hasn't it been solved before? (Or, what's wrong with previous proposed
% solutions? How does mine differ?)
% simple unliftable instances -> recursion

% However, none of the publicly available exact (W)FOMC algorithms can efficiently
% compute functions as simple as a factorial.\footnote{There is some previous work
%   discussing FOMC for
%   factorials~\cite{DBLP:journals/jair/Kuzelka21,DBLP:conf/kr/BremenK21,DBLP:conf/ijcai/Broeck16}.
%   One of them~\cite{DBLP:conf/ijcai/Broeck16} is an example `by hand' that does
%   not directly correspond to any algorithm.
%   Another~\cite{DBLP:journals/jair/Kuzelka21} proves that the problem is
%   liftable but contains no experimental results. The
%   third~\cite{DBLP:conf/kr/BremenK21} contains experimental results performed
%   with an algorithm that is not publicly available.}
% Two more papers to mention:
% 1. The L2C paper has the factorial example as well. But then why doesn't L2C
% work on it?
% 2. \cite{DBLP:journals/corr/abs-2302-04606} computes n! using publicly
% unavailable code

% TODO: add a different introductory problem statement
We claim that the capabilities of (W)FOMC algorithms can be significantly
extended by empowering them with the ability to construct recursive solutions.
The topic of recursion in the context of WFOMC has been studied before but in
limited ways. Barv{\'{\i}}nek et al.~\shortcite{DBLP:conf/ilp/BarvinekB0ZK21}
use WFOMC to generate numerical data that is then used to conjecture recurrence
relations that explain that data. Van den
Broeck~\shortcite{DBLP:conf/nips/Broeck11} introduced the idea of \emph{domain
  recursion}. Intuitively, domain recursion partitions a domain of size $n$ into
a single explicitly named constant and the remaining domain of size $n-1$.
However, many stringent conditions are enforced to ensure that the search for a
tractable solution always terminates.

% 5. What are the key components of my approach and results? Also include any
% specific limitations.

% 5.1) An overview of how ForcLift/Crane work.

In this work, we show how to relax these restrictions in a way that results in a
stronger (W)FOMC algorithm, capable of handling more instances (e.g., counting
various injective mappings) in a lifted manner. The ideas presented in this
paper are implemented in \textsc{Crane}---an extension of the arguably most
well-known WFOMC algorithm \textsc{ForcLift}. \textsc{ForcLift} works in two
stages: compilation and evaluation/propagation. In the first stage, various
\emph{(compilation) rules} are applied to the input (or some derivative)
formula, gradually constructing a circuit. In the second stage, the weights of
the instance are propagated through the circuit, computing the weighted model
count. Along with new compilation rules, \textsc{Crane} introduces changes to
both stages of the process. First, while \textsc{ForcLift} applies compilation
rules via greedy search, \textsc{Crane} also supports a hybrid search algorithm
that applies some rules greedily and some using breadth-first
search.\footnote{In the current implementation, the rules that are applied in a
  non-greedy fashion are: atom counting, inclusion-exclusion, independent
  partial groundings, Shannon decomposition, shattering, and two of our new
  rules introduced in \cref{sec:dr,sec:ref}---see previous
  work~\cite{DBLP:conf/ijcai/BroeckTMDR11} for more information about the
  rules.} This alternative was introduced because there is no reason to expect
greedy search to be optimal. Second, the product of compilation is not directly
evaluated but rather interpreted as a collection of functions on domain sizes.
Hence, our approach is reminiscent of previous work on lifted inference via
compilation to C++ programs~\cite{DBLP:conf/kr/KazemiP16} and the broader area
of functional
synthesis~\cite{DBLP:conf/cav/GoliaRM20,DBLP:conf/pldi/KuncakMPS10,sanathanan1963transfer}.

% 5.2) The main idea: cycles that represent recursive calls.

The main conceptual difference between \textsc{Crane} and \textsc{ForcLift} is
that we utilise labelled directed graphs instead of circuits, where cycles
represent recursive calls. Suppose the input formula $\phi$ depends on a domain
of size $n \in \mathbb{N}_{0}$. \emph{Generalised domain recursion} (GDR)---one
of the new compilation rules---transforms $\phi$ into a different formula $\psi$
that has an additional constant and some new \emph{constraints}. After some
additional transformations, the constraints in $\psi$ become `uniform' and can
be removed, replacing the domain of size $n$ with a new domain of size
$n-1$---this is the responsibility of the \emph{constraint removal} (CR)
compilation rule. Afterwards, another compilation rule recognizes that the
resulting formula is just like the input formula $\phi$ but with a different
domain. This observation allows us to add a cycle-forming edge to the graph,
which can be interpreted as function $f$ relying on $f(n-1)$ to compute $f(n)$.

% 5.3) contributions, references to sections, shortcomings

We begin by defining the representation used for sentences in first-order logic
in \cref{sec:recprelims}. Then, in \cref{sec:methods}, we define the graphs that
replace circuits in representing a solution to a (W)FOMC problem.
\Cref{sec:rules} introduces the new compilation rules. In \cref{sec:interpret},
we discuss how a graph can be interpreted as a collection of (potentially
recursive) functions. In \cref{sec:results}, we compare \textsc{ForcLift} and
\textsc{Crane} on a range of function-counting problems. We show that
\textsc{Crane} performs as well as \textsc{ForcLift} on the instances that were
already solvable by \textsc{ForcLift} but is also able to handle most of the
instances that \textsc{ForcLift} fails on. Finally, in \cref{sec:conclusion}, we
conclude by outlining some conjectures and directions for future work.

\section{Preliminaries}\label{sec:recprelims}

Our representation of FOMC instances is largely based on the format used
internally by \textsc{ForcLift}, some aspects of which are described by Van den
Broeck et al.~\shortcite{DBLP:conf/ijcai/BroeckTMDR11}. \textsc{ForcLift} can
translate sentences in a variant of function-free many-sorted first-order logic
with equality to this internal format. We use lowercase Latin letters for
predicates (e.g., $\texttt{p}$) and constants (e.g., $x$), uppercase Latin
letters for variables (e.g., $X$), and uppercase Greek letters for domains
(e.g., $\Delta$). Sometimes we write predicate $\texttt{p}$ as $\texttt{p}/n$,
where $n \in \mathbb{N}^{+}$ is the \emph{arity} of $\texttt{p}$. An \emph{atom}
is $\texttt{p}(t_1, \dots, t_n)$ for some predicate $\texttt{p}/n$ and terms
$t_{1}, \dots, t_{n}$. A \emph{term} is either a constant or a variable. A
\emph{literal} is either an atom or the negation of an atom (denoted by
$\neg \texttt{p}(t_1, \dots, t_n)$). Let $\mathcal{D}$ be the set of all
relevant (finite) domains. Initially, $\mathcal{D}$ contains all domains
mentioned by the input formula. During compilation, new domains are added to
$\mathcal{D}$ by some of the compilation rules. Each such new domain is
interpreted as a subset of some other domain in $\mathcal{D}$.

We use $\langle\cdot\rangle$ to denote lists, $|\cdot|$ for the length of a
list, and $\mdoubleplus$ for list concatenation. We write $\pfun$ to denote
partial functions and $\dom(\cdot)$ for the domain of a function. Let $\Doms$ be
the function that maps any clause or formula to the set of domains used within.
Similarly, let $\Vars$ be the function that maps clauses and sets of either
literals or constraints to the set of variables in them. Let $S$ be a set of
constraints or literals, $V$ a set of variables, and $x$ a variable or a
constant. We write $S[x/V]$ to denote $S$ with all occurrences of all variables
in $V$ replaced with $x$.

\begin{definition}[Constraint]\label{def:constraint}
  An \emph{(inequality) constraint} is a pair $(a, b)$, where $a$ is a variable,
  and $b$ is either a variable or a constant. As the name implies, it constrains
  $a$ and $b$ to be unequal.
\end{definition}

\begin{definition}[Clause]\label{def:clause}
  A \emph{clause} is a triple $c = (L, E, \delta_c)$, where $L$ is a set of
  literals, $E$ is a set of constraints, and $\delta_c$ is the domain map.
  \emph{Domain map} $\delta_{c}\colon \Vars(c) \to \mathcal{D}$ is a function
  that maps all variables in $c$ to their domains such that (s.t.) if
  $(X, Y) \in E$ for some variables $X$ and $Y$, then
  $\delta_c(X) = \delta_c(Y)$. For convenience, we sometimes write $\delta_c$
  for the domain map of $c$ without unpacking $c$ into its three constituents.
\end{definition}

\begin{definition}[Formula]\label{def:formula}
  A \emph{formula} is a set of clauses s.t.\ all constraints and atoms `type
  check' with respect to domains.
\end{definition}

\begin{example}\label{example:first}
  Let $\phi \coloneqq \{\, c_1, c_2 \,\}$ be a formula with clauses
  \begin{align*}
    c_1 &\coloneqq
          \begin{multlined}[t]
            (\{\, \neg \texttt{p}(X, Y), \neg \texttt{p}(X, Z) \,\}, \{\, (Y, Z) \,\}, \\
            \{\, X \mapsto \Gamma, Y \mapsto \Delta, Z \mapsto \Delta \,\}),
          \end{multlined}\\
    c_2 &\coloneqq
          \begin{multlined}[t]
            (\{\, \neg \texttt{p}(X, Y), \neg \texttt{p}(Z, Y) \,\}, \{\, (X, Z) \,\}, \\
            \{\, X \mapsto \Gamma, Y \mapsto \Delta, Z \mapsto \Gamma \,\})
          \end{multlined}
  \end{align*}
  for some predicate $\texttt{p}/2$, variables $X$, $Y$, $Z$, and domains
  $\Gamma$ and $\Delta$. All variables that occur as the first argument to
  $\texttt{p}$ are in $\Gamma$, and, likewise, all variables that occur as the
  second argument to $\texttt{p}$ are in $\Delta$. Therefore, $\phi$ `type
  checks' as a valid formula.
\end{example}

One can read a formula in our format as a sentence in first-order logic. All
variables in a clause are implicitly universally quantified, and all clauses in
a formula are implicitly linked by a conjunction. Thus, formula $\phi$ from
\cref{example:first} reads as
\begin{equation}\label[formula]{eq:formula}
  \begin{split}
    &\begin{multlined}[t]
      (\forall X \in \Gamma\text{. }\forall Y, Z \in \Delta\text{. }\\
      Y \ne Z \Rightarrow \neg \texttt{p}(X, Y) \lor \neg \texttt{p}(X, Z)) \land{}
    \end{multlined}\\
    &\begin{multlined}[t]
      (\forall X, Z \in \Gamma\text{. }\forall Y \in \Delta\text{. }\\
      X \ne Z \Rightarrow \neg \texttt{p}(X, Y) \lor \neg \texttt{p}(Z, Y)).
    \end{multlined}
  \end{split}
\end{equation}

There are two major differences between
\cref{def:constraint,def:clause,def:formula} and the corresponding concepts
introduced by Van den Broeck et
al.~\shortcite{DBLP:conf/ijcai/BroeckTMDR11}.\footnote{Van den Broeck et
  al.~\shortcite{DBLP:conf/ijcai/BroeckTMDR11} refer to clauses and formulas as
  c-clauses and c-theories, respectively.} First, we decouple variable-to-domain
assignments from constraints and move them to a separate function $\delta_{c}$
in \cref{def:clause}. Second, while they allow for equality constraints and
constraints of the form $X \not\in \Delta$ for some variable $X$ and domain
$\Delta$, we exclude such constraints simply because they are not needed. Note
that if, e.g., $Y \ne Z$ in \cref{eq:formula} is replaced by $Y = Z$, then
\cref{eq:formula} can be simplified to have one fewer variables. Similarly, if
the same inequality is replaced by $Y = c$ for some constant $c$, then $Y$ can
be eliminated as well. Since constraints are always interpreted as preconditions
for the disjunction of literals in the clause (as in \cref{eq:formula}),
equality constraints can be eliminated without any loss in expressivity.

\begin{example}\label{example:simple}
  Let $\Delta$ be a domain of size $n \in \mathbb{N}_{0}$. The model count of
  $\forall X \in \Delta\text{. } \texttt{p}(X) \lor \texttt{q}(X)$ is then
  $3^{n}$. Intuitively, since both predicates are of arity one, they can be
  interpreted as subsets of $\Delta$. Thus, the formula says that each element
  of $\Delta$ has to be included in $\texttt{p}$ or in $\texttt{q}$ or in both,
  i.e., there are three possibilities.
\end{example}

\begin{example}\label{example:smokers}
  Consider a variant of the well-known `friends and smokers' example
  $\forall X, Y \in \Delta\text{.
  } \smokes(X) \land \friends(X, Y) \Rightarrow \smokes(Y)$. Letting
  $n \coloneqq |\Delta|$ as in \cref{example:simple}, the model count can be
  expressed as
  $\sum_{k=0}^{n} \binom{n}{k}2^{n^{2} - k(n-k)}$~\cite{DBLP:conf/kr/BroeckMD14}.
\end{example}

The model count of a formula $\phi$ also depends on the sizes of the domains in
$\phi$. Let $\sigma\colon \mathcal{D} \to \mathbb{N}_{0}$ be the \emph{domain
  size function} that maps each domain to a non-negative integer.

\begin{example}
  Let $\phi$ be as in \cref{example:first} and let
  $\Gamma = \Delta = \{\,1, 2\,\}$, i.e., $\sigma(\Gamma) = \sigma(\Delta) = 2$.
  There are $2^{2 \times 2} = 16$ possible relations between $\Gamma$ and
  $\Delta$. Let us count how many of them satisfy the conditions imposed on
  predicate $\texttt{p}$. The empty relation does. All four relations of
  cardinality one (e.g., $\{\, (1, 1) \,\}$) do too. Finally, there are two
  relations of cardinality two ($\{\, (1, 1), (2, 2) \,\}$ and
  $\{\, (1, 2), (2, 1) \,\}$) that satisfy the conditions as well. Thus, the
  FOMC of $(\phi, \sigma)$ is 7. Incidentally, the FOMC of $\phi$ counts partial
  injections from $\Gamma$ to $\Delta$. We will continue to use the problem of
  counting partial injections (and the formula from \cref{example:first}
  specifically) as the main running example.
\end{example}

\section{First-Order Computational Graphs}\label{sec:methods}

\begin{figure}[t]
  \centering
  \begin{forest}
    for tree={s sep=10mm, sn edges}
    [$\bigwedge_{x \in \Delta}$,ellipse,draw,label=right:{\color{blue}{$3^{n}$}}
    [$\lor$,ellipse,draw,label=right:{\color{blue}{$2 + 1 = 3$}}
    [$\land$,ellipse,draw,label=left:{\color{blue}{$2 \times 1 = 2$}}
    [$p(x) \lor \neg p(x)$,rectangle,draw,fill=gray!25,label=below:{\color{blue}{2}}]
    [$\land$,ellipse,draw,label={[label distance=0cm,text=blue]87:$1 \times 1 = 1$}
    [$q(x)$,rectangle,draw,fill=gray!25,label=below:{\color{blue}{1}}]
    [$\top$,rectangle,draw,fill=gray!25,label=below:{\color{blue}{1}}]
    ]
    ]
    [$\land$,ellipse,draw,label=right:{\color{blue}{$1 \times 1 = 1$}}
    [$\neg q(x)$,rectangle,draw,fill=gray!25,label=below:{\color{blue}{1}}]
    [$p(x)$,rectangle,draw,fill=gray!25,label=below:{\color{blue}{1}}]
    ]
    ]
    ]
  \end{forest}
  \caption{A circuit produced by \textsc{ForcLift} for \cref{example:simple}.
    Values and computations in blue (on the outside of each node) show how a
    bottom-up evaluation of the circuit computes the model
    count.}\label{fig:simplecircuit}
\end{figure}

Darwiche~\shortcite{DBLP:journals/jancl/Darwiche01} introduced
\emph{deterministic decomposable negation normal form} (d-DNNF) circuits for
propositional knowledge compilation and showed that the model count of a
propositional formula can be computed in time linear in the size of the circuit.
Van den Broeck et al.~\shortcite{DBLP:conf/ijcai/BroeckTMDR11} generalised them
to first-order logic via \emph{first-order d-DNNF (FO d-DNNF) circuits}. FO
d-DNNF circuits (hereafter simply called \emph{circuits}) are directed acyclic
graphs with nodes corresponding to formulas in first-order logic---see
\cref{fig:simplecircuit} for an example. The following types of nodes are
supported by \textsc{ForcLift}: caching ($\Reff$), contradiction ($\bot$),
tautology ($\top$), decomposable conjunction ($\land$), decomposable
set-conjunction ($\bigwedge$), deterministic disjunction ($\lor$), deterministic
set-disjunction ($\bigvee$), domain recursion, grounding, inclusion-exclusion,
smoothing, and unit clause. We refer the reader to previous
work~\cite{DBLP:conf/nips/Broeck11,DBLP:conf/ijcai/BroeckTMDR11} for more
information about node types and their interpretations for computing the
(W)FOMC\@.

\begin{figure}[t]
  \centering
  \begin{forest}
    for tree={sn edges}
    [$\GDR$,ellipse,draw,name=gdr
    [$\bigvee_{\Delta^\top \subseteq \Delta}$,ellipse,draw
    [$\CR_{\Gamma \mapsto \Gamma'}$,ellipse,draw
    [$\land$,ellipse,draw
    [$\bot$,rectangle,draw,fill=gray!25]
    [$\Reff_{\{\, \Gamma \mapsto \Gamma', \Delta \mapsto \Delta^{\bot} \,\}}$,ellipse,draw,name=ref]
    ]
    ]
    ]
    ]
    \draw[-Latex,bend right=45] (ref) to (gdr);
  \end{forest}
  \caption{A simplified version of the FCG constructed by \textsc{Crane} for the
    problem of counting partial injections from \cref{example:first}. Here we
    omit some parameters as well as nodes whose only arithmetic effect is
    multiplication by one.}\label{fig:examplefcg}
\end{figure}

In this paper, we introduce \emph{first-order computational graphs} (FCGs) that
generalise circuits by dispensing with acyclicity. Formally, an FCG is a (weakly
connected) directed graph with a single source, node labels, and ordered
outgoing edges. Node labels consist of two parts: the \emph{type} and the
\emph{parameters}. The type of a node determines its out-degree. We make the
following changes and additions to the node types already supported by
\textsc{ForcLift}. First, we introduce a new node type for constraint removal
($\CR$). Second, we replace domain recursion with generalised domain recursion
($\GDR$). And third, for reasoning about partially-constructed FCGs, we write
$\star$ for a placeholder type that is yet to be replaced. We write $T_p$ for an
FCG that has a node with label $T_p$ (i.e., type $T$ and parameter(s) $p$) and
$\star$'s as all of its direct successors. We also write $T_p(v)$ for an FCG
with one edge from a node labelled $T_{p}$ to some other node $v$ (and no other
nodes or edges). See \cref{fig:examplefcg} for an example FCG\@.

% Connecting FCGs with formulas
Finally, we introduce a structure that represents a solution to a (W)FOMC
problem while it is still being built. A \emph{chip} is a pair $(G, L)$, where
$G$ is an FCG, and $L$ is a list of formulas, s.t. $|L|$ is equal to the number
of $\star$'s in $G$. $L$ contains formulas that still need to be compiled. Once
a formula is compiled, it replaces one of the $\star$'s in $G$ according to a
set order. We say that an FCG is \emph{complete} (i.e., it represents a
\emph{complete solution}) if it has no $\star$'s. Similarly, a chip is complete
if its FCG is complete (or, equivalently, the list of formulas is empty).

\section{New Compilation Rules}\label{sec:rules}

A \emph{(compilation) rule} takes a formula and returns a set of chips. The
cardinality of this set is the number of different ways in which the rule can be
applied to the input formula. While
\textsc{ForcLift}~\cite{DBLP:conf/ijcai/BroeckTMDR11} heuristically chooses one
of them, in an attempt to not miss a solution, \textsc{Crane} returns them all.
In particular, if a rule returns an empty set, then that rule does not apply to
the formula.

\subsection{Generalised Domain Recursion}\label{sec:dr}

% Main idea
The main idea behind domain recursion (both the original version by Van den
Broeck~\shortcite{DBLP:conf/nips/Broeck11} and the one presented here) is as
follows. Let $\Omega \in \mathcal{D}$ be a domain. Assuming that
$\Omega \ne \emptyset$, pick some $x \in \Omega$. Then, for every variable
$X \in \Omega$ that occurs in a literal, consider two possibilities: $X = x$ and
$X \ne x$.

\begin{example}\label{example:dr}
  Let $\phi$ be a formula with a single clause
  \begin{multline*}
    (\{\, \neg \texttt{p}(X, Y), \neg \texttt{p}(X, Z) \,\}, \{\, (Y, Z) \,\}, \\
    \{\, X \mapsto \Gamma, Y \mapsto \Delta, Z \mapsto \Delta \,\}).
  \end{multline*}
  Then we can introduce constant $x \in \Gamma$ and rewrite $\phi$ as
  $\phi' = \{\, c_{1}, c_{2} \,\}$, where
  \begin{align*}
    c_{1} &= \begin{multlined}[t]
      (\{\, \neg \texttt{p}(x, Y), \neg \texttt{p}(x, Z) \,\}, \{\, (Y, Z) \,\}, \\
      \{\, Y \mapsto \Delta, Z \mapsto \Delta \,\}),
      \end{multlined}\\
    c_{2} &= \begin{multlined}[t]
      (\{\, \neg \texttt{p}(X, Y), \neg \texttt{p}(X, Z) \,\}, \{\, (X, x), (Y, Z) \,\}, \\
      \{\, X \mapsto \Gamma', Y \mapsto \Delta, Z \mapsto \Delta \,\}),
      \end{multlined}
  \end{align*}
  and $\Gamma' = \Gamma \setminus \{\, x \,\}$.
\end{example}

% Original domain recursion
Van den Broeck~\shortcite{DBLP:conf/nips/Broeck11} imposes stringent conditions
on the input formula to ensure that the expanded version of the formula (as in
\cref{example:dr}) can be handled efficiently. For instance,
\cref{example:first} cannot be handled by \textsc{ForcLift} because there is no
root binding class, i.e., the two root variables belong to different equivalence
classes with respect to the binding relationship. The clauses in this expanded
formula are then partitioned into three parts based on whether the
transformation introduced constants or constraints or both. The aforementioned
conditions ensure that these parts can be treated independently.

\begin{algorithm}[t]
  \caption{The compilation rule for $\GDR$ nodes.}\label{alg:domainrecursion}
  \KwIn{formula $\phi$, set of all relevant domains $\mathcal{D}$}
  \KwOut{set of chips $S$}
  $S \gets \emptyset$\;
  \ForEach{domain $\Omega \in \mathcal{D}$ s.t.\ there is $c \in \phi$ and $X \in \Vars(L_c)$ s.t. $\delta_c(X) = \Omega$\label{line:condition}}{
    $\phi' \gets \emptyset$\;
    $x \gets \text{a new constant in domain } \Omega$\;\label{line:constant}
    \ForEach{clause $c = (L, E, \delta) \in \phi$\label{line:forclause}}{
      $V \gets \{\, X \in \Vars(L) \mid \delta(X) = \Omega \,\}$\;\label{line:V}
      \ForEach{$W \subseteq V$ s.t. $W^2 \cap E = \emptyset$ {\bf and} $W \cap \{\, X \in \Vars(E) \mid (X, y) \in E \text{ for some constant } y \,\} = \emptyset$\label{line:conditions}}{
        \tcc{$\delta'$ restricts $\delta$ to the new set of variables}
        $\phi' \gets \phi' \cup \{\, (L[x/W], E[x/W] \cup \{\, (X, x) \mid (X \in V \setminus W) \,\}, \delta') \,\}$\;\label{line:generation}
      }
    }
    $S \gets S \cup \{\, (\GDR, \langle\phi'\rangle) \,\}$\;
  }
\end{algorithm}

% Description of GDR, in contrast to DR
In contrast, GDR has only one precondition: for GDR to be applicable on domain
$\Omega \in \mathcal{D}$, there must be at least one variable with domain
$\Omega$ that is featured in a literal (and not just in constraints). Without
such variables, GDR would have no effect on the formula. GDR is also simpler in
that the expanded formula is left as-is to be handled by other compilation
rules. Typically, after a few more rules are applied, a combination of $\CR$ and
$\Reff$ nodes introduces a cycle-inducing edge back to the $\GDR$ node, thus
completing the definition of a recursive function. The GDR compilation rule is
summarised as \cref{alg:domainrecursion} and explained in more detail using the
example below.

\begin{example}
  Let $\phi \coloneqq \{\, c_1, c_2 \,\}$ be the formula from
  \cref{example:first}. While GDR is possible on both domains, here we
  illustrate how it works on $\Gamma$. Having chosen a domain, the algorithm
  iterates over the clauses of $\phi$. Suppose \cref{line:forclause} picks
  $c = c_1$ as the first clause. Then, set $V$ is constructed to contain all
  variables with domain $\Omega = \Gamma$ that occur in the literals of clause
  $c$. In this case, $V = \{\, X \,\}$.

  \Cref{line:conditions} iterates over all subsets $W \subseteq V$ of variables
  that can be replaced by a constant without resulting in evidently
  unsatisfiable formulas. We impose two restrictions on $W$. First,
  $W^2 \cap E = \emptyset$ ensures that there are no pairs of variables in $W$
  that are constrained to be distinct, since that would result in an $x \ne x$
  constraint after substitution. Similarly, we want to avoid variables in $W$
  that have inequality constraints with constants: after the substitution, such
  constraints would transform into inequality constraints between two constants.
  In this case, both subsets of $V$ satisfy these conditions, and
  \cref{line:generation} generates two clauses for the output formula:
  \begin{multline*}
    (\{\, \neg \texttt{p}(X, Y), \neg \texttt{p}(X, Z) \,\}, \{\, (Y, Z), (X, x) \,\}, \\
    \{\, X \mapsto \Gamma, Y \mapsto \Delta, Z \mapsto \Delta \,\}),
  \end{multline*}
  from $W = \emptyset$ and
  \[
    (\{\, \neg \texttt{p}(x, Y), \neg \texttt{p}(x, Z) \,\}, \{\, (Y, Z) \,\}, \{\, Y \mapsto \Delta, Z \mapsto \Delta \,\})
  \]
  from $W = V$.

  When \cref{line:forclause} picks $c = c_2$, then $V = \{\, X, Z \,\}$. The
  subset $W = V$ fails to satisfy the conditions on \cref{line:conditions}
  because of the $X \ne Z$ constraint. The other three subsets of $V$ all
  generate clauses for $\phi'$. Indeed, $W = \emptyset$ generates
  \begin{multline*}
    (\{\, \neg \texttt{p}(X, Y), \neg \texttt{p}(Z, Y) \,\}, \{\, (X, Z), (X, x), (Z, x) \,\}, \\
    \{\, X \mapsto \Gamma, Y \mapsto \Delta, Z \mapsto \Gamma \,\}),
  \end{multline*}
  $W = \{\, X \,\}$ generates
  \[
    (\{\, \neg \texttt{p}(x, Y), \neg \texttt{p}(Z, Y) \,\}, \{\, (Z, x) \,\}, \{\, Y \mapsto \Delta, Z \mapsto \Gamma \,\}),
  \]
  and $W = \{\, Z \,\}$ generates
  \[
    (\{\, \neg \texttt{p}(X, Y), \neg \texttt{p}(x, Y) \,\}, \{\, (X, x) \,\}, \{\, X \mapsto \Gamma, Y \mapsto \Delta \,\}).
  \]
\end{example}

\begin{theorem}[Correctness of $\GDR$]\label{thm:correctness1}
  Let $\phi$ be the formula used as input to \cref{alg:domainrecursion},
  $\Omega \in \mathcal{D}$ the domain selected on \cref{line:condition}, and
  $\phi'$ the formula constructed by the algorithm for $\Omega$. Suppose that
  $\Omega \ne \emptyset$. Then $\phi \equiv \phi'$.
\end{theorem}

Note that \Cref{thm:correctness1} is equivalent to Proposition~3 by Van den
Broeck~\shortcite{DBLP:conf/nips/Broeck11}. For the proofs of this and other
theorems, see supplementary material.

\subsection{Constraint Removal}\label{sec:cr}

Recall that GDR on a domain $\Omega$ creates constraints of the form $X_i \ne x$
for some constant $x \in \Omega$ and family of variables $X_i \in \Omega$. Once
certain conditions are satisfied, we can eliminate these constraints and replace
$\Omega$ with a new domain $\Omega'$, which can be interpreted as
$\Omega \setminus \{\, x \,\}$. These conditions are that a constraint of the
form $X \ne x$ exists for all variables $X \in \Omega$ across all clauses, and
such constraints are the only place where $x$ occurs. We formalise the
conditions as \cref{def:replaceable}.

\begin{definition}\label{def:replaceable}
  With respect to a formula $\phi$, a pair $(\Omega, x)$ of a domain
  $\Omega \in \mathcal{D}$ and its element $x \in \Omega$ is called
  \emph{replaceable} if
  \begin{enumerate*}[label=(\roman*)]
    \item $x$ does not occur in any literal of any clause of $\phi$, and
    \item for each clause $c = (L, E, \delta_c) \in \phi$ and variable
    $X \in \Vars(c)$, either $\delta_c(X) \ne \Omega$ or $(X, x) \in E$.
  \end{enumerate*}
\end{definition}

\begin{algorithm}[t]
  \caption{The compilation rule for $\CR$ nodes.}\label{alg:constraintremoval}
  \KwIn{formula $\phi$, set of all relevant domains $\mathcal{D}$}
  \KwOut{set of chips $S$}
  $S \gets \emptyset$\;
  \ForEach{replaceable pair $(\Omega \in \mathcal{D}, x \in \Omega)$\label{line:crconditions}}{
    add a new domain $\Omega'$ to $\mathcal{D}$\;\label{line:newdomain}
    $\phi' \gets \emptyset$\;
    \ForEach{clause $(L, E, \delta) \in \phi$}{
      $E' \gets \{\, (a, b) \in E \mid b \ne x \,\}$\;\label{line:constraintremoval}
      \nosemic$\delta' \gets X \mapsto
      \begin{cases}
        \Omega' & \text{if } \delta(X) = \Omega\\
        \delta(X) & \text{otherwise;}
      \end{cases}$\;\label{line:newdelta}
      $\phi' \gets \phi' \cup \{\, (L, E', \delta') \,\}$\;
    }
    $S \gets S \cup \{\, (\CR_{\Omega \mapsto \Omega'}, \langle\phi'\rangle) \,\}$\;
  }
\end{algorithm}

Once a replaceable pair is found, \cref{alg:constraintremoval} proceeds to
construct the new formula by removing constraints (on
\cref{line:constraintremoval}) and constructing a new domain map $\delta'$ that
replaces $\Omega$ with $\Omega'$ (on \cref{line:newdelta}).

\begin{example}
  Let $\phi = \{\, c_1, c_2 \,\}$ be a formula with clauses
  \begin{align*}
    c_1 &=
          \begin{multlined}[t]
            (\{\, \neg \texttt{p}(X, Y), \neg \texttt{p}(X, Z) \,\}, \{\, (X, x), (Y, Z) \,\}, \\
            \{\, X \mapsto \Gamma, Y \mapsto \Delta, Z \mapsto \Delta \,\}),
          \end{multlined}\\
    c_2 &=
          \begin{multlined}[t]
            (\{\, \neg \texttt{p}(X, Y), \neg \texttt{p}(Z, Y) \,\}, \\
            \{\, (X, x), (Z, X), (Z, x) \,\}, \\
            \{\, X \mapsto \Gamma, Y \mapsto \Delta, Z \mapsto \Gamma \,\}).
          \end{multlined}
  \end{align*}
  Domain $\Gamma$ and its element $x \in \Gamma$ satisfy the preconditions for
  CR\@. The rule introduces a new domain $\Gamma'$ and transforms $\phi$ to
  $\phi' = (c_1', c_2')$, where
  \begin{align*}
    c_1' &=
           \begin{multlined}[t]
             (\{\, \neg \texttt{p}(X, Y), \neg \texttt{p}(X, Z) \,\}, \{\, (Y, Z) \,\}, \\
             \{\, X \mapsto \Gamma', Y \mapsto \Delta, Z \mapsto \Delta \,\}),
           \end{multlined} \\
    c_2' &=
           \begin{multlined}[t]
             (\{\, \neg \texttt{p}(X, Y), \neg \texttt{p}(Z, Y) \,\}, \{\, (Z, X) \,\}, \\
             \{\, X \mapsto \Gamma', Y \mapsto \Delta, Z \mapsto \Gamma' \,\}).
           \end{multlined}
  \end{align*}
\end{example}

\begin{theorem}[Correctness of $\CR$]
  Let $\phi$ be the input formula of \cref{alg:constraintremoval}, $(\Omega, x)$
  a replaceable pair, and $\phi'$ the formula constructed by the algorithm, when
  $(\Omega, x)$ is selected on \cref{line:crconditions}. Then
  $\phi \equiv \phi'$, where the domain $\Omega'$ introduced on
  \cref{line:newdomain} is interpreted as $\Omega \setminus \{\, x \,\}$.
\end{theorem}

There is no analogue to $\CR$ in previous work on first-order knowledge
compilation. $\CR$ plays a key role by recognising when the constraints of a
formula essentially reduce the size of a domain by one and extracting this
observation into the definition of a new domain. This then allows us to relate
maps between sets of domains to the arguments of a function call.
\Cref{sec:ref,sec:interpret} describe this process.

\subsection{Identifying Opportunities for Recursion}\label{sec:ref}

\paragraph{Hashing.}
We use (integer-valued) hash functions to discard pairs of formulas that are too
different for recursion to work. The hash code of a clause
$c = (L, E, \delta_{c})$ (denoted by $\# c$) combines the hash codes of the sets
of constants and predicates in $c$, the numbers of positive and negative
literals, the number of inequality constraints $|E|$, and the number of
variables $|\Vars(c)|$. The hash code of a formula $\phi$ combines the hash
codes of all its clauses and is denoted by $\#\phi$.

\paragraph{Caching.}
\textsc{ForcLift}~\cite{DBLP:conf/ijcai/BroeckTMDR11} uses a cache to check if
a formula is identical to one of the formulas that have already been fully
compiled. To facilitate recursion, we extend the caching scheme to include
formulas that have been encountered but not fully compiled yet. Formally, we
define a \emph{cache} to be a map from integers (e.g., hash codes) to sets of
pairs of the form $(\phi, v)$, where $\phi$ is a formula, and $v$ is an FCG
node.

\begin{algorithm}[t]
  \caption{The compilation rule for $\Reff$ nodes.}\label{alg:trycache}
  \KwIn{formula $\phi$, cache $C$}
  \KwOut{a set of chips}

  \ForEach{formula and node $(\psi, v) \in C(\#\phi)$}{\label{line:selectformula}
    $\rho \gets \identifyRecursion{$\phi$, $\psi$}$\;
    \lIf{$\rho \ne {\normalfont \texttt{null}}$}{\Return{$\{\, (\Reff_\rho(v), \langle\rangle) \,\}$}}\label{line:rho}
  }
  \Return{$\emptyset$}\;

  \Fn{\identifyRecursion{formula $\phi$, formula $\psi$, map $\rho = \emptyset$}}{
    \lIf{$|\phi| \ne |\psi|$ {\bf or} $\#\phi \ne \#\psi$}{\Return{\normalfont\texttt{null}}}
    \lIf{$\phi = \emptyset$}{\Return{$\rho$}}
    \ForEach{clause $c \in \psi$\label{line:for1}}{
      \ForEach{clause $d \in \phi$ s.t. $\#d=\#c$\label{line:for2}}{
        \ForAll{$\gamma \in \generateMaps{$c$, $d$, $\rho$}$\label{line:generateMaps}}{
          $\rho' \gets \identifyRecursion{$\phi\setminus\{\, d \,\}$, $\psi\setminus\{\, c \,\}$, $\rho\cup\gamma$}$\;\label{line:recursion}
          \lIf{$\rho' \ne {\normalfont \texttt{null}}$}{\Return{$\rho'$}}
        }
      }
      \Return{\normalfont\texttt{null}}\;
    }
  }
\end{algorithm}

% Cache $C$ is used to partition all previously-encountered formulas based on
% their hash codes.
\Cref{alg:trycache} describes the compilation rule for creating $\Reff$ nodes.
For every formula $\psi$ in the cache s.t. $\#\psi = \#\phi$, function
\texttt{r} is called to check whether a recursive call is feasible. If it is,
\texttt{r} returns a (total) map $\rho\colon \Doms(\psi) \to \Doms(\phi)$ that
shows how $\psi$ can be transformed into $\phi$ by replacing each domain
$\Omega \in \Doms(\psi)$ with $\rho(\Omega) \in \Doms(\phi)$. Otherwise,
\texttt{r} returns \texttt{null} to signify that $\phi$ and $\psi$ are too
different for recursion to work. This happens if $\phi$ and $\psi$ (or their
subformulas explored in recursive calls) are structurally different (i.e., the
numbers of clauses or the hash codes fail to match) or if a clause of $\psi$
cannot be paired with a sufficiently similar clause of $\phi$. Function
\texttt{r} works by iterating over pairs of clauses of $\phi$ and $\psi$ that
have the same hash codes. For every pair of sufficiently similar clauses,
\texttt{r} calls itself on the remaining clauses until the map
$\rho\colon \Doms(\psi) \pfun \Doms(\phi)$ becomes total, and all clauses are
successfully coupled.

Function \texttt{genMaps} checks the compatibility of a pair of clauses. It
considers every possible bijection $\beta\colon \Vars(c) \to \Vars(d)$ and map
$\gamma\colon \Doms(c) \to \Doms(d)$ s.t.
\[
  \begin{tikzcd}
    \Vars(c) \ar[r, dashed, "\beta"] \arrow[d, swap, "\delta_c"] & \Vars(d) \ar[d, "\delta_d"] \\
    \Doms(c) \ar[r, dashed, "\gamma"] \ar[d, hookrightarrow] & \Doms(d) \ar[d, hookrightarrow] \\
    \Doms(\psi) \ar[r, swap, "\rho", "|" marking, outer sep=5pt] & \Doms(\phi).
  \end{tikzcd}
\]
commutes, and $c$ becomes equal to $d$ when its variables are replaced according
to $\beta$ and its domains replaced according to $\gamma$. The function then
returns each such $\gamma$ as soon as possible. The commutativity check also
ensures that $\rho \cup \gamma$ is possible on \cref{line:recursion} of
\cref{alg:trycache}. The resulting (partial) function $\rho \cup \gamma$ is the
unique function s.t. $\rho \cup \gamma|_{\dom(\rho)} = \rho$, and
$\rho \cup \gamma|_{\dom(\gamma)} = \gamma$. The operation is defined when
$\rho|_{\dom(\rho)\cap\dom(\gamma)} = \gamma|_{\dom(\rho)\cap\dom(\gamma)}$.

\begin{theorem}[Correctness of $\Reff$]
  Let $\phi$ be the formula used as input to \cref{alg:trycache}. Let $\psi$ be
  any formula selected on \cref{line:selectformula} of the algorithm s.t.\
  $\rho \ne {\normalfont\texttt{null}}$ on \cref{line:rho}. Let $\sigma$ be a
  domain size function. Then the set of models of $(\psi, \sigma \circ \rho)$ is
  equal to the set of models of $(\phi, \sigma)$.
\end{theorem}

As \textsc{ForcLift} only supports $\Reff$ nodes for when the two formulas are
equal, our approach is significantly more general and can even construct more
complex recursive calls such as $f(n-k-2)$.

\section{Converting FCGs to Function Definitions}\label{sec:interpret}

\begin{algorithm}[t]
  \caption{Construct functions from an FCG}\label{alg:interpretation}
  \SetKwProg{Fn}{Function}{:}{}

  \SetKwData{functionCall}{call}
  \SetKwData{functionSignature}{signature}
  \SetKwData{functionNames}{F}
  \SetKwData{domainNames}{D}
  \SetKwData{newDomainNames}{D'}
  \SetKwData{expression}{e}
  \SetKwData{functions}{funs}
  \SetKwData{args}{args}

  \SetKwFunction{newFunctionName}{newFunctionName}
  \SetKwFunction{newDomainName}{newDomainName}
  \SetKwFunction{visit}{v}
  \SetKwFunction{actuallyVisit}{visit}

  \KwIn{$\mathcal{D}$---the set of domains of the input formula}
  \KwIn{$s$---the source node of the FCG}
  \KwData{$\functionNames = \emptyset$ (function names)}
  \KwOut{a list of function definitions}
  $\domainNames \gets \{\, \Omega \mapsto \newDomainName{} \mid \Omega \in \mathcal{D} \,\}$\;\label{line:varnames}
  \tcc{Equivalent condition: $s$ has in-degree greater than one.}
  \If{$s$ is a direct successor of a $\Reff$ node}{
    $(\expression, \functions) \gets \visit{$s$, $\domainNames$}$\;\label{line:initialcall}
    \Return{\functions}\;\label{line:initialcalltwo}
  }
  $f \gets \newFunctionName{$s$}$\;
  $(\expression, \functions) \gets \visit{$s$, $\domainNames$}$\;
  \Return{$\langle f(\langle \domainNames{$\Omega$} \mid \Omega \in \mathcal{D} \rangle) = \expression \rangle \mdoubleplus \functions$}\;
  \Fn{\visit{node $v$, domain names \domainNames}}{
    \If{$v$ is \textbf{not} a direct successor of a $\Reff$ node}{
      \Return{\actuallyVisit{$v$, \domainNames}}\;
    }
    $f \gets \newFunctionName{$v$}$\;
    $\newDomainNames \gets \domainNames$\;
    \For{$\Omega \in \mathfrak{D}(v)$ s.t. $\newDomainNames(\Omega)$ is non-atomic}{\label{line:nonone}
      $\newDomainNames(\Omega) \gets \newDomainName{}$\;\label{line:nontwo}
    }
    $(\expression, \functions) \gets \actuallyVisit{$v$, \newDomainNames}$\;\label{line:actuallyvisit}
    $\functionCall \gets f(\langle \domainNames{$\Omega$} \mid \Omega \in \mathfrak{D}(v) \rangle)$\;
    $\functionSignature \gets f(\langle \newDomainNames{$\Omega$} \mid \Omega \in \mathfrak{D}(v) \rangle)$\;
    \Return{$(\functionCall, \langle \functionSignature = \expression \rangle \mdoubleplus \functions)$}\;
  }
  \Fn{\actuallyVisit{node $v$, domain names \domainNames}}{
    \Switch{label of $v$}{
      \lCase{$\GDR(v')$}{\Return{\visit{$v'$, \domainNames}}}
      \uCase{$\CR_{\Omega \mapsto \Omega'}(v')$}{
        \Return{\visit{$v'$, $\domainNames \cup \{\, \Omega' \mapsto (\domainNames(\Omega) - 1) \,\}$}}\;\label{line:cr}
      }
      \uCase{$\Reff_{\rho}(v')$}{
        $\args \gets \langle \domainNames\circ\rho(\Omega) \mid \Omega \in \mathfrak{D}(v') \rangle$\;\label{line:args}
        \Return{$(\functionNames{$v'$}(\args), \langle \rangle)$}\;
      }
      \dots
    }
  }
\end{algorithm}

\Cref{alg:interpretation} describes how to construct a list of function
definitions from a (complete) FCG\@. The algorithm consists of two main
functions: \visit and \actuallyVisit. The former handles new function
definitions while the latter produces an algebraic interpretation of each node
depending on its type. As there are many node types, we only include the ones
pertinent to the contributions of this paper; see previous
work~\cite{DBLP:conf/ijcai/BroeckTMDR11} for information about the other types.
Given some node $v$ as input, both \visit and \actuallyVisit return a pair
$(\mathsf{e}, \mathsf{funs})$. Here, $\mathsf{e}$ is the algebraic expression
that represent $v$, and $\mathsf{funs}$ is a list of auxiliary functions that
were created while formulating $\mathsf{e}$.

The algorithm gradually constructs two partial maps $\mathsf{F}$ and
$\mathsf{D}$ that give names to functions and domains, respectively.
$\mathsf{F}$ is a global variable that maps FCG nodes to function names (e.g.,
$f$, $g$). $\mathsf{D}$ maps domains to their names, and it is passed as an
argument to \visit and \actuallyVisit. Here, a \emph{domain name} is either a
parameter of a function or an algebraic expression consisting of function
parameters, subtraction, and parentheses. We call a domain name \emph{atomic} if
it is free of subtraction (e.g., $m$, $n$); otherwise it is \emph{non-atomic}
(e.g., $m-1$, $n-l$). Functions \newDomainName and \newFunctionName both
generate previously-unused names. The latter also takes an FCG node as input and
links it with the new name in $\mathsf{F}$.

We assume a fixed total ordering of all domains. In particular, in
\cref{example:interpretation} below we assume that $\Gamma$ goes before
$\Delta$. For each node $v$, let $\mathfrak{D}(v)$ denote the (precomputed) list
of domains, the sizes of which we would use as parameters if we were to define a
function that begins at $v$. As a set, it is computed by iteratively setting
$\mathfrak{D}(v) \gets \left(\bigcup_{u} \mathfrak{D}(u) \setminus I_{v}\right) \cup U_{v}$
until convergence, where:
\begin{enumerate*}[label=(\roman*)]
  \item the union is over all direct successors of $v$,
  \item $I_{v}$ is the set of domains \emph{introduced} at node $v$, and
  \item $U_{v}$ is the set of domains \emph{used} by $v$.
\end{enumerate*}
The set is then sorted according to the fixed ordering of domains.

\begin{figure}
  \centering
  \begin{tikzcd}
    \ar[d] & \\
    \text{\Cref{alg:interpretation}} \ar[d] \ar[u, swap, shift right=0.7ex, "{\left\langle f(m, n) = \sum_{l=0}^{n}[l<2]f(m-1,n-l) \right\rangle}"] & \\
    \visit{$\GDR$, $\Done$} \ar[d] \ar[u, swap, shift right=0.7ex, "\left({f(m, n), \left\langle f(m, n) = \sum_{l=0}^{n}[l<2]f(m-1,n-l) \right\rangle}\right)"] & \\
    \actuallyVisit{$\GDR$, $\Done$} \ar[d] \ar[u, swap, shift right=0.7ex, "\left({\sum_{l=0}^{n}[l<2]f(m-1,n-l), \langle\rangle}\right)"] & \\
    \visit/\actuallyVisit{$\bigvee$, $\Done$} \ar[d] \ar[u, swap, shift right=0.7ex, "\left({\sum_{l=0}^{n}[l<2]f(m-1,n-l), \langle\rangle}\right)"] & \\
    \visit/\actuallyVisit{$\CR$, $\Dtwo$} \ar[d] \ar[u, swap, shift right=0.7ex, "\left({[l<2]f(m-1,n-l), \langle\rangle}\right)"] & \\
    \visit/\actuallyVisit{$\land$, $\Dthree$} \ar[d] \ar[dr] \ar[u, swap, shift right=0.7ex, "\left({[l<2]f(m-1,n-l), \langle\rangle}\right)"] & \\
    \visit/\actuallyVisit{$\bot$, $\Dthree$} \ar[u, swap, shift right=0.7ex, "\left({[l<2], \langle\rangle}\right)"] & \visit/\actuallyVisit{$\Reff$, $\Dthree$} \ar[ul, swap, shift right=0.7ex, "\left({f(m-1, n-l), \langle\rangle}\right)"]
  \end{tikzcd}
  \caption{Function calls and their return values when \cref{alg:interpretation}
    is run on the FCG from \cref{fig:examplefcg}}\label{fig:functioncalls}
\end{figure}

\begin{example}\label{example:interpretation}
  Here we examine how \cref{alg:interpretation} works on the FCG from
  \cref{fig:examplefcg}. In this case, $\mathcal{D} = \{\, \Gamma, \Delta \,\}$.
  Let $\Done \coloneqq \{\, \Gamma \mapsto m, \Delta \mapsto n \,\}$,
  $\Dtwo \coloneqq \Done \cup \{\, \Delta^{\top} \mapsto l, \Delta^{\bot} \mapsto (n-l) \,\}$,
  and $\Dthree \coloneqq \Dtwo \cup \{\, \Gamma' \mapsto (m-1) \,\}$ denote
  versions of $\mathsf{D}$ at various points throughout the algorithm's
  execution. Here, $l$, $m$, and $n$ are all arbitrary names generated by
  \newDomainName.

  \Cref{fig:functioncalls} shows the outline of function calls and their return
  values. For simplicity, we refer to FCG nodes by their types. When \visit
  calls \actuallyVisit and returns its output unchanged, the two function calls
  are shortened as a single call to $\visit/\actuallyVisit$.

  \Cref{line:varnames} initialises $\mathsf{D}$ to $\Done$. Once \visit{$\GDR$,
    $\Done$} is called on \cref{line:initialcall}, \newFunctionName updates
  $\mathsf{F}$ to $\{\, \GDR \mapsto f \,\}$, where $f$ is a new function name.
  There are no non-atomic names in $\Done$, so \cref{line:nonone,line:nontwo}
  are skipped, and calls to \actuallyVisit{$\GDR$, $\Done$} and
  $\visit/\actuallyVisit{$\bigvee$, $\Done$}$ follow. Here, $\Done$ becomes
  $\Dtwo$, i.e., the $\bigvee$ node introduces two domains $\Delta^{\top}$ and
  $\Delta^{\bot}$ that `partition' $\Delta$, i.e.,
  $\Dtwo(\Delta^{\top}) + \Dtwo(\Delta^{\bot}) = l + (n-l) = n = \Dtwo(\Delta)$.
  Similarly, \actuallyVisit{$\CR$, $\Dtwo$} on \cref{line:cr} adds $\Gamma'$,
  replacing $\Dtwo$ with $\Dthree$.

  Eventually, \actuallyVisit{$\bot$, $\Dthree$} is called. A contradiction node
  with clause $c$ as a parameter is interpreted as one if the clause has
  groundings and zero otherwise. In this case, the parameter is
  $c = (\emptyset, \{\, (X, Y) \,\}, \{\, X \mapsto \Delta^\top, Y \mapsto \Delta^\top \,\})$
  (not shown in \cref{fig:examplefcg}). Equivalently,
  $\forall X, Y \in \Delta^{\top}\text{. }X \ne Y \Rightarrow \bot$, i.e.,
  $\forall X, Y \in \Delta^{\top}\text{. }X = Y$. This sentence is true if and
  only if $\Dthree(\Delta^{\top}) < 2$. Thus, we can use the Iverson bracket
  notation to write
  \[
    [l < 2] \coloneqq
    \begin{cases}
      1 & \text{if } l < 2 \\
      0 & \text{otherwise.}
    \end{cases}
  \]
  for the output expression of \actuallyVisit{$\bot$, $\Dthree$}.

  Next, \actuallyVisit{$\land$, $\Dthree$} calls
  $\visit/\actuallyVisit{$\Reff$, $\Dthree$}$. Since
  $\mathfrak{D}(\GDR) = \langle \Gamma, \Delta \rangle$, and the pair
  $\langle\Gamma, \Delta\rangle$ is transformed by $\Dthree{} \circ \rho$ as
  \[
    \begin{tikzcd}
      \langle\Gamma, \Delta\rangle \ar[r, mapsto, "\rho"] & \langle\Gamma', \Delta^{\bot}\rangle \ar[r, mapsto, "\Dthree"] & \langle m-1, n-l \rangle,
    \end{tikzcd}
  \]
  \textsf{args} is set to $\langle m-1, n-l \rangle$ on \cref{line:args}, and
  the output expression becomes $f(m-1, n-l)$. The call to
  \actuallyVisit{$\land$, $\Dthree$} then returns the product of the two
  expressions $[l<2]f(m-1, n-l)$. Next, the call to \actuallyVisit{$\bigvee$,
    $\Done$} prepends a summation and returns $\sum_{l=0}^{n}[l<2]f(m-1,n-l)$.
  The same expression (and an empty list of functions) is then returned to
  \cref{line:actuallyvisit} of the call to \visit{$\GDR$, $\Done$}. Here, both
  \textsf{call} and \textsf{signature} are set to $f(m, n)$. As the definition
  of $f$ is the final answer and not part of some other algebraic expression,
  \cref{line:initialcall,line:initialcalltwo} discard the function call
  expression and return the definition of $f$. Thus,
  \begin{align}
    f(m, n) &= \sum_{l = 0}^{n} \binom{n}{l} [l < 2] f(m-1, n-l)\nonumber \\
            &= f(m-1, n) + n f(m-1, n-1)\label{eq:solution}
  \end{align}
  is the function that \textsc{Crane} constructed for computing partial
  injections. To use $f$ in practice, one just needs to identify the base cases
  $f(0, n)$ and $f(m, 0)$ for all $m, n \in \mathbb{N}_{0}$.
\end{example}

\section{Experimental Results}\label{sec:results}
% TODO: rename 'experimental results' -> 'complexity results' (not just the
% title of the section but review every mention of the word 'experimental')
% TODO: make it clear that I'm not doing this by hand anymore, but I'm still
% removing multiplications by one.
% TODO (here or somewhere else): emphasise that there are two parts: search
% (with some artificial limit) + inference (whose complexity we can easily
% determine)
% TODO: describe ternary.mln as an example instance that's not in C^2 that can
% be lifted
% TODO: say that 'f' will always denote the main function

\begin{table*}[t]
  \centering
  \begin{tabular}{cccccc}
    \toprule
    \multicolumn{3}{c}{Function Class} & \multicolumn{3}{c}{Asymptotic Complexity of Counting} \\
    Partial & Endo- & Class & Best Known & With \textsc{ForcLift} & With \textsc{Crane} \\
    \midrule
    \rowcolor{gray!25}\cmark/\xmark & \cmark/\xmark & Functions & $\log m$ & $m$ & $m$ \\
    \xmark & \xmark & \multirow{2}{*}{Surjections} & $n \log m$ & $m^{3}+n^{3}$ & $m^{3}+n^{3}$ \\
    \xmark & \cmark & & $m \log m$ & $m^{3}$ & $m^{3}$ \\
    \rowcolor{gray!25}\xmark & \xmark & & $m$ & --- & $mn$ \\
    \rowcolor{gray!25}\xmark & \cmark & & $m$ & --- & $m^3$ \\
    \rowcolor{gray!25}\cmark & \xmark & & ${\min\{\, m, n \,\}}^2$ & --- & $mn$ \\
    \rowcolor{gray!25}\cmark & \cmark & \multirow{-4}{*}{Injections} & $m^2$ & --- & --- \\
    \xmark & \xmark & Bijections & $m$ & --- & $m$ \\
    \bottomrule
  \end{tabular}
  \caption{The worst-case complexity of counting various types of functions,
    where $m$ is the size of domain $\Gamma$, and $n$ is the size of domain
    $\Delta$. All asymptotic complexities are in $\Theta(\cdot)$. A dash means
    that the algorithm was not able to find a solution.}\label{tbl:results}
\end{table*}
% TODO: 'Asymptotic Complexity of Counting' -> 'Complexity of \mathcal{F}_\phi'
% (introduce \mathcal{F}_\phi in the introduction, together with the flow graph)

% TODO: Explain (in text) why there are fewer than 16 rows in the table. And
% don't say 'same as', instead say that the formulas are in some sense
% equivalent (maybe in a stronger sense than the usual equivalence).

% TODO: emphasise that the reader should focus on the last two columns
% TODO: the caption sentence about not finding a solution could be confusing
% TODO: 'best known' sounds disappointing. Find a better alternative.

% TODO: I think I said this the last time, but along with the complexities as a
% way of representing the empirical evaluation, I think you should also include
% a few plots, even if they say nothing more than what the table already says.
% The point is that the readers can see what this behaviour looks like so even
% if you include a few plots and say we just give a few representative examples
% and the rest follow the table of all that will be better

We compare \textsc{Crane} and
\textsc{ForcLift}\footnote{\url{https://dtaid.cs.kuleuven.be/wfomc}}~\cite{DBLP:conf/ijcai/BroeckTMDR11}
on their ability to count various kinds of functions. This class of instances is
chosen because of its simplicity and ubiquity and the inability of
state-of-the-art WFOMC algorithms to solve many such instances. Note that other
WFOMC algorithms mentioned in \cref{sec:introduction} are unable to solve any of
the instances that \textsc{ForcLift} fails on. We begin by describing how such
function-counting problems can be expressed in first-order logic.
\textsc{ForcLift} then translates these sentences in first-order logic to
formulas as defined in \cref{def:formula}.

Let $\texttt{p}$ be a predicate that models relations between sets $\Gamma$ and
$\Delta$. To restrict all such relations to just $\Gamma \to \Delta$ functions,
in first-order logic one might write
\[
  \forall X \in \Gamma\text{. }\forall Y,Z \in \Delta\text{. }\texttt{p}(X, Y) \land \texttt{p}(X, Z) \Rightarrow Y = Z
\]
and
\begin{equation}\label{eq:def2}
  \forall X \in \Gamma\text{. }\exists Y \in \Delta\text{. }\texttt{p}(X, Y).
\end{equation}
The former sentence says that one element of $\Gamma$ can map to at \emph{most}
one element of $\Delta$, and the latter sentence says that each element of
$\Gamma$ must map to at \emph{least} one element of $\Delta$. One can then add
\[
  \forall X,Z \in \Gamma\text{. }\forall Y \in \Delta\text{. }\texttt{p}(X, Y) \land \texttt{p}(Z, Y) \Rightarrow X = Z
\]
to restrict $\texttt{p}$ to injections or
  $\forall Y \in \Delta\text{. }\exists X \in \Gamma\text{. }\texttt{p}(X, Y)$
to ensure surjectivity or remove \cref{eq:def2} to consider partial functions.
Lastly, one can replace all occurrences of $\Delta$ with $\Gamma$ to model
endofunctions (i.e., functions with the same domain and codomain) instead.

% the process: both for running algorithms and for determining complexities
In our experiments, we consider all sixteen combinations of these properties,
i.e., injectivity, surjectivity, partiality, and endo-. We run each algorithm
once on each of the sixteen instances.\footnote{While domain sizes have to be
  specified as part of the input, they are immaterial to the search procedure.}
\textsc{Crane} is run in hybrid search mode until either five solutions are
found or the search tree reaches height six. \textsc{ForcLift} is always run
until it terminates. If successful, \textsc{ForcLift} generates a circuit, and
\textsc{Crane} generates one or more (complete) FCGs. In both cases, we manually
convert the resulting graphs into definitions of functions as described in
\cref{sec:interpret}. We then assess the complexity of each solution by hand and
pick the best in case \textsc{Crane} returns several solutions of varying
complexities.

% \footnote{The search tree has a high
%   branching factor, so exploring all nodes at depth five takes at most a few
%   seconds, whereas doing the same for depth six can be computationally
%   infeasible in some cases.}

% how the complexity of a solution is determined
Previous work often compares WFOMC algorithms by running them on a few instances
with increasing domain sizes and measuring
runtime~\cite{DBLP:conf/nips/Broeck11,DBLP:conf/ijcai/BroeckTMDR11,DBLP:conf/aaai/BroeckD12}.
However, we can do much better and identify the exact worst-case asymptotic
complexity of a solution produced by either \textsc{Crane} or \textsc{ForcLift}.
The asymptotic complexity of a solution can be determined by considering the
total number of arithmetic operations needed to follow the definitions of
constituent functions without recomputing the same quantity multiple times. In
particular, we assume that each function call and binomial coefficient is
computed at most once. We also assume that computing $\binom{n}{k}$ takes
$\Theta(nk)$ time. For example, the complexity of \cref{eq:solution} is
$\Theta(mn)$ since $f(m, n)$ can be computed by a dynamic programming algorithm
that computes $f(i, j)$ for all $i = 0, \dots, m$ and $j = 0, \dots, n$, taking
a constant amount of time on the computation of each $f(i, j)$.
% TODO: look for a better place to put the 'In particular...' remark

The experimental results are summarised in \cref{tbl:results}, where we compare
the solutions found by both algorithms to the best known ways of computing the
same quantities. The best-known asymptotic complexity for computing total
surjections is by Earnest~\shortcite{30049}. All other best-known complexity
results are inferred from the formulas and programs on the on-line encyclopedia
of integer sequences~\cite{oeis}. On instances that could already be solved by
\textsc{ForcLift}, the two algorithms perform equally well. However,
\textsc{Crane} can also solve all but one of the instances that
\textsc{ForcLift} fails on in at most cubic time. See supplementary material for
the exact solutions produced by \textsc{Crane} that correspond to the complexity
results in \cref{tbl:results}. We also note that standard (W)FOMC benchmarks
such as \cref{example:smokers} that are already supported by \textsc{ForcLift}
remain feasible for \textsc{Crane} as well. Moreover, our algorithm can also
handle the linear order axiom, for which a bespoke algorithm was recently
proposed by T{\'{o}}th and
Ku\v{z}elka~\shortcite{DBLP:journals/corr/abs-2211-01164}.

\section{Conclusion and Future Work}\label{sec:conclusion}

In this paper, we showed how a state-of-the-art (W)FOMC algorithm can be
empowered by generalising domain recursion and adding support for cycles in the
graph that encodes a solution. To construct such graphs, \textsc{Crane}
supplements \textsc{ForcLift}~\cite{DBLP:conf/ijcai/BroeckTMDR11} with three
new compilation rules. Our experiments revealed a range of counting problems
that are liftable to \textsc{Crane} but not to any other (W)FOMC algorithm.
Although in this paper we focus on unweighted counting, \textsc{ForcLift}'s
support for weights trivially transfers to \textsc{Crane} as well. The common
thread across these newly liftable problems is (partial) injectivity. Thus, we
can formulate the following conjecture.

\begin{conjecture}
  Let \IFO{} be the class of formulas in first-order logic that contain clauses
  with at most two variables as well as any number of copies of
  \begin{align*}
    &\begin{multlined}[t]
      (\forall X \in \Gamma\text{. }\forall Y, Z \in \Delta\text{. }\\
      Y \ne Z \Rightarrow \neg \texttt{\textup{p}}(X, Y) \lor \neg \texttt{\textup{p}}(X, Z)) \land{}
    \end{multlined}\\
    &\begin{multlined}[t]
      (\forall X, Z \in \Gamma\text{. }\forall Y \in \Delta\text{. }\\
      X \ne Z \Rightarrow \neg \texttt{\textup{p}}(X, Y) \lor \neg \texttt{\textup{p}}(Z, Y))
    \end{multlined}
  \end{align*}
  for some predicate $\texttt{\textup{p}}/2$ and domains $\Gamma$ and $\Delta$.
  Then \IFO{} is liftable by \textsc{Crane}.
\end{conjecture}

Recall that \Ctwo{} is the class of formulas with counting quantifiers and at
most two variables. \Ctwo{} was recently shown to be
liftable~\cite{DBLP:journals/jair/Kuzelka21} but without providing a usable
(W)FOMC algorithm. Since the tasks of counting injections and bijections fall
into the \Ctwo{} fragment, we can conjecture the following.

\begin{conjecture}
  \Ctwo{} is liftable by \textsc{Crane} by either reformulating formulas in
  \Ctwo{} to avoid counting quantifiers or extending \textsc{Crane} to support
  them.
\end{conjecture}

However, the most important direction for future work is to fully automate this
new process. First, we need an algorithm that transforms FCGs into definitions
of functions. Formalising this process would also allow us to prove the
correctness of the new compilation rules in constructing FCGs that indeed
compute the right (weighted) model counts. Second, these definitions must be
simplified before they can be used, perhaps by a computer algebra system. Third,
we need a way to find the base cases for the recursive definitions provided by
\textsc{Crane}. Fourth, since the first solution found by \textsc{Crane} is not
always optimal in terms of its complexity, an automated way to determine the
asymptotic complexity of a solution would be helpful as well. Achieving these
goals would enable \textsc{Crane} to automatically constructing efficient ways
to compute various functions and sequences. In addition to the potential impact
on areas of artificial intelligence (AI) such as statistical relational
AI~\cite{DBLP:series/synthesis/2016Raedt}, \textsc{Crane} could be beneficial to
research in combinatorics as
well~\cite{DBLP:conf/ilp/BarvinekB0ZK21,DBLP:journals/corr/abs-2302-04606}.

\bibliographystyle{kr}
\bibliography{paper}

\end{document}
