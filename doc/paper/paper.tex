\documentclass{article}
\pdfpagewidth=8.5in
\pdfpageheight=11in

\usepackage{kr}

% Use the postscript times font!
\usepackage{times}
\usepackage{soul}
\usepackage{url}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[small]{caption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{booktabs}
% \usepackage{algorithm}
% \usepackage{algorithmic}
\urlstyle{same}

\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{pifont}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{tikz}
\usepackage[capitalize]{cleveref}
\usepackage{multirow}
\usepackage{colortbl}
\usepackage{complexity}
\usepackage{siunitx}
\usepackage{forest}
\usepackage[inline]{enumitem}

\usetikzlibrary{cd}
\usetikzlibrary{shapes}

% the following package is optional:
%\usepackage{latexsym}

% See https://www.overleaf.com/learn/latex/theorems_and_proofs
% for a nice explanation of how to define new theorems, but keep
% in mind that the amsthm package is already included in this
% template and that you must *not* alter the styling.
% \newtheorem{example}{Example}
\newtheorem{theorem}{Theorem}
\newtheorem{fact}{Fact}
\newtheorem{proposition}{Proposition}
\newtheorem{conjecture}{Conjecture}
\newtheorem{claim}{Claim}[theorem]
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}

\pdfinfo{
/TemplateVersion (KR.2022.0, KR.2023.0)
}

\title{Synthesising Recursive Functions for First-Order Model Counting}

% TODO (at the very end)
% grammarly the whole thing
% read the formatting instructions and their LaTeX source (email font?)
% make sure there are no overflow errors
% make sure the result table (as well as other floating objects) are on the right pages

\author{%
Paulius Dilkas$^1$\and
Vaishak Belle$^2$\\
\affiliations
$^1$National University of Singapore, Singapore, Singapore\\
$^2$University of Edinburgh, Edinburgh, UK\\
\emails
paulius.dilkas@nus.edu.sg,
vbelle@ed.ac.uk
}

\crefalias{diagram}{equation}
\crefname{diagram}{Diagram}{Diagrams}
\Crefname{diagram}{Diagram}{Diagrams}
\creflabelformat{diagram}{#2\textup{(#1)}#3}

\crefname{algocf}{Algorithm}{Algorithms}
\Crefname{algocf}{Algorithm}{Algorithms}
\crefname{condition}{Condition}{Conditions}
\Crefname{condition}{Condition}{Conditions}

\newcommand{\crefrangeconjunction}{--}
\newcommand\pfun{\mathrel{\ooalign{\hfil$\mapstochar\mkern5mu$\hfil\cr$\to$\cr}}}
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\newcommand{\FOtwo}{$\mathsf{FO}^{2}$}
\newcommand{\FOthree}{$\mathsf{FO}^{3}$}
\newcommand{\SFO}{$\mathsf{S}^{2}\mathsf{FO}^{2}$}
\newcommand{\SRU}{$\mathsf{S}^{2}\mathsf{RU}$}
\newcommand{\Uone}{$\mathsf{U}_{1}$}
\newcommand{\Ctwo}{$\mathsf{C}^{2}$}
\newcommand{\IFO}{$\mathsf{I}\mathsf{FO}^{2}$}

\DeclareMathOperator{\friends}{\texttt{friends}}
\DeclareMathOperator{\smokes}{\texttt{smokes}}
\DeclareMathOperator{\CR}{\textsc{CR}}
\DeclareMathOperator{\GDR}{\textsc{GDR}}
\DeclareMathOperator{\Reff}{\textsc{Ref}}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\Doms}{Doms}
\DeclareMathOperator{\Vars}{Vars}
\DeclareMathOperator{\Preds}{Preds}
\SetKwProg{Fn}{Function}{:}{}
\SetKwFunction{identifyRecursion}{r}
\SetKwFunction{generateMaps}{genMaps}

\makeatletter
\newcommand{\nosemic}{\renewcommand{\@endalgocfline}{\relax}}% Drop semi-colon ;
\newcommand{\dosemic}{\renewcommand{\@endalgocfline}{\algocf@endline}}% Reinstate semi-colon ;
\newcommand{\pushline}{\Indp}% Indent
\newcommand{\popline}{\Indm\dosemic}% Undent
\makeatother
\Crefname{algocf}{Algorithm}{Algorithms}
\crefname{line}{line}{lines}

\forestset{
sn edges/.style={for tree={edge={-Latex}}}
}

\begin{document}

\maketitle

\begin{abstract}
  First-order model counting (FOMC) is a computational problem that asks to
  count the models of a sentence in finite-domain first-order logic. Despite
  being around for more than a decade, practical FOMC algorithms are still
  unable to compute functions as simple as a factorial. We argue that the
  capabilities of FOMC algorithms to date are limited by their inability to
  express arbitrary recursive computations. To enable arbitrary recursion, we
  relax the restrictions that typically accompany domain recursion and
  generalise circuits used to express a solution to an FOMC problem to graphs
  that may contain cycles. To this end, we enhance the most well-established
  (weighted) FOMC algorithm \textsc{ForcLift} with new compilation rules and an
  algorithm to check whether a recursive call is feasible. These improvements
  allow the algorithm to construct efficient solutions to counting fundamental
  structures such as injections and bijections. We end with a few conjectures on
  what classes of instances could be liftable as a result.
\end{abstract}

\section{Introduction}\label{sec:introduction}

% 1. What is the problem?
% 2. Why is it interesting and important?

\emph{First-order model counting} (FOMC) is the problem of computing the number
of models of a sentence in first-order logic (FOL) given the size(s) of its
domain(s)~\cite{DBLP:conf/pods/BeameBGS15}. \emph{Symmetric weighted FOMC}
(WFOMC) extends FOMC with (pairs of) weights on predicates and asks for a
weighted sum across all models instead. By fixing the sizes of the domains, a
WFOMC instance can be rewritten as an instance of (propositional) weighted model
counting~\cite{DBLP:journals/ai/ChaviraD08}. WFOMC emerged as the dominant
approach to \emph{lifted (probabilistic) inference}. Lifted inference techniques
exploit symmetries in probabilistic models by reasoning about sets rather than
individuals~\cite{DBLP:conf/ecai/Kersting12}. By doing so, many instances become
solvable in polynomial time~\cite{DBLP:conf/nips/Broeck11}. Lifted inference
algorithms are typically used on probabilistic models such as probabilistic
programming
languages~\cite{DBLP:journals/ml/RaedtK15,DBLP:journals/ijar/RiguzziBZCL17},
Markov logic
networks~\cite{DBLP:conf/ijcai/BroeckTMDR11,DBLP:journals/cacm/GogateD16,DBLP:journals/ml/RichardsonD06},
and other lifted graphical~\cite{DBLP:journals/ml/KimmigMG15} and statistical
relational~\cite{DBLP:series/synthesis/2016Raedt} models. Lifted inference
techniques for probabilistic databases, while developed somewhat independently,
have also been inspired by
WFOMC~\cite{DBLP:journals/pvldb/GatterbauerS15,DBLP:journals/debu/GribkoffSB14}.
While WFOMC has received more attention in the literature, FOMC is an
interesting problem in an of itself because of its connections to finite model
theory~\cite{DBLP:conf/kr/BremenK21} and applications in enumerative
combinatorics~\cite{DBLP:conf/ilp/BarvinekB0ZK21}. There is also a recent line
of work that uses FOMC-based methods to count solutions to constraint
satisfaction problems~\cite{DBLP:journals/jair/TotisDRK23}.

% 3. Why is it hard? (E.g., why do naive approaches fail?)
% complexity/liftability -> murky boundary

Traditionally in computational complexity theory, a problem is \emph{tractable}
if it can be solved in time polynomial in the instance size. The equivalent
notion in (W)FOMC is liftability. A (W)FOMC instance is \emph{(domain-)liftable}
if it can be solved in time polynomial in the size(s) of the
domain(s)~\cite{jaeger2012liftability}. Over more than a decade, many classes of
instances were shown to be
liftable~\cite{DBLP:conf/kr/BremenK21,DBLP:conf/nips/KazemiKBP16,DBLP:conf/lics/KuusistoL18,DBLP:journals/jair/Kuzelka21}.
First, Van den Broeck~\shortcite{DBLP:conf/nips/Broeck11} showed that the class
of all sentences of FOL with up to two variables (denoted \FOtwo{}) is liftable.
Then Beame et al.~\shortcite{DBLP:conf/pods/BeameBGS15} proved that there exists
a sentence with three variables for which FOMC is $\#\P_{1}$-complete (i.e.,
\FOthree{} is not liftable). Since these two seminal results, most of the
research on (W)FOMC focused on developing faster solutions for the \FOtwo{}
fragment~\cite{DBLP:conf/uai/BremenK21,DBLP:conf/aaai/MalhotraS22} and defining
new liftable fragments. These fragments include \SFO{} and
\SRU{}~\cite{DBLP:conf/nips/KazemiKBP16},
\Uone{}~\cite{DBLP:conf/lics/KuusistoL18}, \Ctwo{} (i.e., the two-variable
fragment with counting
quantifiers)~\cite{DBLP:journals/jair/Kuzelka21,DBLP:conf/aaai/MalhotraS22}, and
\Ctwo{} extended with tree axioms~\cite{DBLP:conf/kr/BremenK21} and linear order
axiom~\cite{DBLP:journals/corr/abs-2211-01164}. On the empirical front, there
are several implementations of exact WFOMC algorithms:
\textsc{Alchemy}~\cite{DBLP:journals/cacm/GogateD16},
\textsc{FastWFOMC}~\cite{DBLP:conf/uai/BremenK21},
\textsc{ForcLift}~\cite{DBLP:conf/ijcai/BroeckTMDR11}, and
\textsc{L2C}~\cite{DBLP:conf/kr/KazemiP16}. Approximate counting is supported by
\textsc{Alchemy}, \textsc{ApproxWFOMC}~\cite{DBLP:conf/ijcai/BremenK20},
\textsc{ForcLift}~\cite{DBLP:conf/uai/BroeckCD12},
\textsc{Magician}~\cite{DBLP:conf/aaai/VenugopalSG15}, and
\textsc{Tuffy}~\cite{DBLP:journals/pvldb/NiuRDS11}.

% Magician: an approach to improve the efficiency of sampling and local search
% based MLN inference algorithms by utilising \#CSP algorithms. Tuffy: grounding
% and stochastic local search.

% 4. Why hasn't it been solved before? (Or, what's wrong with previous proposed
% solutions? How does mine differ?)
% simple unliftable instances -> recursion

However, none of the publicly available exact (W)FOMC algorithms can efficiently
compute functions as simple as a factorial.\footnote{There is some previous work
  showing how FOMC can compute
  factorials~\cite{DBLP:journals/jair/Kuzelka21,DBLP:conf/kr/BremenK21,DBLP:conf/ijcai/Broeck16}.
  One of them~\cite{DBLP:conf/ijcai/Broeck16} is an example `by hand' that does
  not directly correspond to any algorithm.
  Another~\cite{DBLP:journals/jair/Kuzelka21} proves that the problem is
  liftable but contains no experimental results. The
  third~\cite{DBLP:conf/kr/BremenK21} contains experimental results performed
  with an algorithm, which is not publicly available.} We claim that the
capabilities of (W)FOMC algorithms can be significantly extended by empowering
them with the ability to construct recursive solutions. The topic of recursion
in the context of WFOMC has been studied before but in limited ways.
Barv{\'{\i}}nek et al.~\shortcite{DBLP:conf/ilp/BarvinekB0ZK21} use WFOMC to
generate numerical data that is then used to conjecture recurrence relations
that explain that data. Van den Broeck~\shortcite{DBLP:conf/nips/Broeck11}
introduced the idea of \emph{domain recursion}. Intuitively, domain recursion
partitions a domain of size $n$ into a single explicitly named constant and the
remaining domain of size $n-1$. However, many stringent conditions are enforced
to ensure that the search for a tractable solution always terminates.

% 5. What are the key components of my approach and results? Also include any
% specific limitations.

% 5.1) An overview of how ForcLift/Crane work.

In this work, we show how to relax these restrictions in a way that results in a
stronger (W)FOMC algorithm, capable of handling more instances (e.g., counting
various injective mappings) in a lifted manner. The ideas presented in this
paper are implemented in \textsc{Crane}---an extension of the arguably most
well-known WFOMC algorithm \textsc{ForcLift}. \textsc{ForcLift} works in two
stages: compilation and evaluation/propagation. In the first stage, various
\emph{(compilation) rules} are applied to the input (or some derivative)
formula, gradually constructing a circuit. In the second stage, the weights of
the instance are propagated through the circuit, computing the weighted model
count. Along with new compilation rules, \textsc{Crane} introduces changes to
both stages of the process. First, while \textsc{ForcLift} applies compilation
rules via greedy search, \textsc{Crane} also supports a hybrid search algorithm
that applies some rules greedily and some using breadth-first
search.\footnote{In the current implementation, the rules that are applied in a
  non-greedy fashion are: atom counting, inclusion-exclusion, independent
  partial groundings, Shannon decomposition, shattering, and two of our new
  rules introduced in \cref{sec:dr,sec:ref}---see previous
  work~\cite{DBLP:conf/ijcai/BroeckTMDR11} for more information about the
  rules.} This alternative was introduced since there is no reason to expect
greedy search to be optimal. Second, the product of compilation is not directly
evaluated but rather interpreted as a collection of functions on domain sizes.
Hence, our approach is reminiscent of previous work on lifted inference via
compilation to C++ programs~\cite{DBLP:conf/kr/KazemiP16} and the broader area
of functional
synthesis~\cite{DBLP:conf/cav/GoliaRM20,DBLP:conf/pldi/KuncakMPS10,sanathanan1963transfer}.

% similarly to the other domains, there are many functions that fit the
% specification, i.e., can correctly count the number of models as a function of
% domain size(s). Whereas in [...] one typically wants to select the smallest
% definition of a function, we are primarily concerned with its worst-case
% complexity as measured by the number of arithmetic operations needed for an
% arbitrary function call
% \begin{itemize}
%   \item Boolean functions~\cite{DBLP:conf/cav/GoliaRM20}
%   \item dynamical systems~\cite{sanathanan1963transfer}
%   \item program fragments~\cite{DBLP:conf/pldi/KuncakMPS10}
% \end{itemize}

% \footnote{There is also an intermediate stage called \emph{smoothing} that takes
%   place between compilation and evaluation. As our changes to smoothing are
%   rather elementary, we do not discuss them to not distract the reader from the
%   main contributions of this paper.}

% 5.2) The main idea: cycles that represent recursive calls.

The main conceptual difference between \textsc{Crane} and \textsc{ForcLift} is
that we utilise labelled directed graphs instead of circuits, where cycles
represent recursive calls. Suppose the input formula $\phi$ depends on a domain
of size $n \in \mathbb{N}_{0}$. \emph{Generalised domain recursion} (GDR)---one
of the new compilation rules---transforms $\phi$ into a different formula $\psi$
that has an additional constant and some new \emph{constraints}. After some
additional transformations, the constraints in $\psi$ become `uniform' and can
be removed, replacing the domain of size $n$ with a new domain of size
$n-1$---this is the responsibility of the \emph{constraint removal} (CR)
compilation rule. Afterwards, another compilation rule recognizes that the
resulting formula is just like the input formula $\phi$ but with a different
domain. This observation allows us to add a cycle-forming edge to the graph,
which can be interpreted as function $f$ relying on $f(n-1)$ to compute $f(n)$.

% 5.3) contributions, references to sections, shortcomings

We begin by defining the representation used for sentences in FOL in
\cref{sec:recprelims}. Then, in \cref{sec:methods}, we define the graphs that
replace circuits in representing a solution to a (W)FOMC problem.
\Cref{sec:rules} introduces the new compilation rules. In \cref{sec:interpret},
we discuss how a graph can be interpreted as a collection of (potentially
recursive) functions. In \cref{sec:results}, we compare \textsc{ForcLift} and
\textsc{Crane} on a range of function-counting problems. We show that
\textsc{Crane} performs as well as \textsc{ForcLift} on the instances that were
already solvable by \textsc{ForcLift} but is also able to handle most of the
instances that \textsc{ForcLift} fails on. Finally, in \cref{sec:conclusion}, we
conclude by outlining some conjectures and directions for future work.

\section{Preliminaries}\label{sec:recprelims}

Our representation of FOMC instances is largely based on the format used
internally by \textsc{ForcLift}, some aspects of which are described by Van den
Broeck et al.~\shortcite{DBLP:conf/ijcai/BroeckTMDR11}. \textsc{ForcLift} can
translate sentences in a variant of function-free many-sorted FOL with equality
to this internal format. We use lowercase Latin letters for predicates (e.g.,
$\texttt{p}$) and constants (e.g., $x$), uppercase Latin letters for variables
(e.g., $X$), and uppercase Greek letters for domains (e.g., $\Delta$). Sometimes
we write predicate $\texttt{p}$ as $\texttt{p}/n$, where $n \in \mathbb{N}^{+}$
is the \emph{arity} of $\texttt{p}$. An \emph{atom} is
$\texttt{p}(t_1, \dots, t_n)$ for some predicate $\texttt{p}/n$ and terms
$t_{1}, \dots, t_{n}$. A \emph{term} is either a constant or a variable. A
\emph{literal} is either an atom or the negation of an atom (denoted by
$\neg \texttt{p}(t_1, \dots, t_n)$). Let $\mathcal{D}$ be the set of all
relevant (finite) domains. Initially, $\mathcal{D}$ contains all domains
mentioned by the input formula. During compilation, new domains are added to
$\mathcal{D}$ by some of the compilation rules. Each such new domain is
interpreted as a subset of some other domain in $\mathcal{D}$.

\begin{definition}[Constraint]\label{def:constraint}
  An \emph{(inequality) constraint} is a pair $(a, b)$, where $a$ is a variable,
  and $b$ is either a variable or a constant.
\end{definition}

\begin{definition}[Clause]\label{def:clause}
  A \emph{clause}\footnote{Van den Broeck et
    al.~\shortcite{DBLP:conf/ijcai/BroeckTMDR11} refer to clauses as c-clauses.}
  is a triple $c = (L, C, \delta_c)$, where $L$ is a set of literals, $C$ is a
  set of constraints, and $\delta_c$ is the domain map of $c$. Let $\Vars$ be
  the function that maps clauses and sets of either literals or constraints to
  the set of variables contained within. In particular,
  $\Vars(c) \coloneqq \Vars(L) \cup \Vars(C)$. \emph{Domain map}
  $\delta_{c}\colon \Vars(c) \to \mathcal{D}$ is a function that maps all
  variables in $c$ to their domains such that (s.t.) if $(X, Y) \in C$ for some
  variables $X$ and $Y$, then $\delta_c(X) = \delta_c(Y)$. For convenience, we
  sometimes write $\delta_c$ for the domain map of $c$ without unpacking $c$
  into its three constituents.
\end{definition}

\paragraph{Notation.}
For any set $S$, let $2^{S}$ denote its power set and
$S^{\ast} \coloneqq \bigcup_{i=0}^{\infty} S^{i}$ the set of tuples of any
finite length of elements of $S$. For any $n \in \mathbb{N}_{0}$, let
$[n] \coloneqq \{\, 1, \dots, n \,\}$. For example, $[0] = \emptyset$, and
$[2] = \{\, 1, 2 \,\}$. We write $\langle\rangle$ for an empty list,
$\langle x \rangle$ for a list with one element $x$, $|l|$ for the length of
list $l$, and $\pfun$ to denote partial functions. Let $S$ be a set of
constraints or literals, $V$ a set of variables, and $x$ a variable or a
constant. We write $S[x/V]$ to denote $S$ with all occurrences of all variables
in $V$ replaced with $x$. Let $\Doms$ (respectively, $\Preds$) be the function
that maps any clause or formula to the set of domains (respectively, predicates)
used within, and let $\dom(f)$ denote the domain of function $f$.

\begin{definition}[Formula]\label{def:formula}
  A \emph{formula} (called a c-theory by Van den Broeck et
  al.~\shortcite{DBLP:conf/ijcai/BroeckTMDR11}) is a set of clauses s.t.\ all
  constraints and atoms `type check' with respect to domains. Each formula
  $\phi$ has a map $\pi_{\phi}\colon \Preds(\phi) \to {\Doms(\phi)}^{\ast}$ such
  that, for each predicate $\texttt{p}/n \in \Preds(\phi)$, we have that
  $\pi_{\phi}(\texttt{p}) \in {\Doms(\phi)}^{n}$.\footnote{Similarly to
    variables and predicates, constants are also mapped to domains, although we
    keep this mapping implicit.}
\end{definition}

\begin{example}\label{example:first}
  Let $\phi \coloneqq \{\, c_1, c_2 \,\}$ be a formula with clauses
  \begin{align*}
    c_1 &\coloneqq
          \begin{multlined}[t]
            (\{\, \neg \texttt{p}(X, Y), \neg \texttt{p}(X, Z) \,\}, \{\, (Y, Z) \,\}, \\
            \{\, X \mapsto \Gamma, Y \mapsto \Delta, Z \mapsto \Delta \,\}),
          \end{multlined}\\
    c_2 &\coloneqq
          \begin{multlined}[t]
            (\{\, \neg \texttt{p}(X, Y), \neg \texttt{p}(Z, Y) \,\}, \{\, (X, Z) \,\}, \\
            \{\, X \mapsto \Gamma, Y \mapsto \Delta, Z \mapsto \Gamma \,\})
          \end{multlined}
  \end{align*}
  for some predicate $\texttt{p}/2$, variables $X$, $Y$, $Z$, and domains
  $\Gamma$ and $\Delta$. Based on $\delta_{c_{1}}$ and $\delta_{c_{2}}$, we can
  infer that $\pi_{\phi} = \{\, \texttt{p} \mapsto (\Gamma, \Delta) \,\}$. All
  variables that occur as the first argument to $\texttt{p}$ are in $\Gamma$,
  and, likewise, all variables that occur as the second argument to $\texttt{p}$
  are in $\Delta$. Therefore, $\phi$ `type checks' as a valid formula.
\end{example}

There are two major differences between
\cref{def:constraint,def:clause,def:formula} and the corresponding concepts
introduced by Van den Broeck et al.~\shortcite{DBLP:conf/ijcai/BroeckTMDR11}.
First, we decouple variable-to-domain assignments from constraints and move them
to a separate function $\delta_{c}$ in \cref{def:clause}. Second, while Van den
Broeck et al.~\shortcite{DBLP:conf/ijcai/BroeckTMDR11} allow for equality
constraints and constraints of the form $X \not\in \Delta$ for some variable $X$
and domain $\Delta$, we exclude such constraints simply because they are not
needed.

One can read a formula in our format as a sentence in FOL\@. All variables in a
clause are implicitly universally quantified (but note that variables are never
shared among clauses), and all clauses in a formula are implicitly linked by a
conjunction. Thus, formula $\phi$ from \cref{example:first} reads as
\begin{align*}
  &\begin{multlined}[t]
    (\forall X \in \Gamma\text{. }\forall Y, Z \in \Delta\text{. }\\
    Y \ne Z \Rightarrow \neg \texttt{p}(X, Y) \lor \neg \texttt{p}(X, Z)) \land
    \end{multlined}\\
  &\begin{multlined}[t]
    (\forall X, Z \in \Gamma\text{. }\forall Y \in \Delta\text{. }\\
    X \ne Z \Rightarrow \neg \texttt{p}(X, Y) \lor \neg \texttt{p}(Z, Y)).
    \end{multlined}
\end{align*}

Once domains are mapped to finite sets and constants to elements in those sets,
a formula can be viewed as a set of conditions that the predicates (interpreted
as relations) have to satisfy. Hence, FOMC is the problem of counting the number
of combinations of relations that satisfy these conditions.

\begin{example}\label{example:simple}
  Let $\Delta$ be a domain of size $n \in \mathbb{N}_{0}$. The model count of
  $\forall X \in \Delta\text{. } \texttt{p}(X) \lor \texttt{q}(X)$ is then
  $3^{n}$. Intuitively, since both predicates are of arity one, they can be
  interpreted as subsets of $\Delta$. Thus, the formula says that each element
  of $\Delta$ has to be included in $\texttt{p}$ or in $\texttt{q}$ or in both,
  i.e., there are three possibilities.
\end{example}

\begin{example}\label{example:smokers}
  Consider a variant of the well-known `friends and smokers' example
  $\forall X, Y \in \Delta\text{.
  } \smokes(X) \land \friends(X, Y) \Rightarrow \smokes(Y)$. Letting
  $n \coloneqq |\Delta|$ as in \cref{example:simple}, the model count can be
  expressed as
  $\sum_{k=0}^{n} \binom{n}{k}2^{n^{2} - k(n-k)}$~\cite{DBLP:conf/kr/BroeckMD14}.
\end{example}

To formalise the idea of a model, let
$\sigma\colon \mathcal{D} \to \mathbb{N}_{0}$ be the \emph{domain size function}
that maps each domain to a non-negative integer.

\begin{definition}\label{def:model}
  Let $\phi$ be a formula and $\sigma$ a domain size function. A \emph{model} of
  $(\phi, \sigma)$ is a map
  $\mathfrak{M}\colon \Preds(\phi) \to 2^{\mathbb{N}_{0}^{\ast}}$ such that the
  following two conditions are satisfied.
  \begin{enumerate}
    \item Let $\texttt{p}/n \in \Preds(\phi)$ be a predicate and let
          $\pi_{\phi}(\texttt{p}) = {(d_{i})}_{i=1}^{n}$ for some domains
          $d_{i} \in \Doms(\phi)$. Then
          \begin{equation}\label{eq:subset}
            \mathfrak{M}(\texttt{p}) \subseteq \prod_{i=1}^{n}[\sigma(d_{i})].\footnote{For simplicity, \cref{def:model} ignores constants. To include constants, one would replace $[\sigma(d_{i})]$ with a set that contains all constants associated with domain $d_{i}$, extended with enough new elements to make its cardinality $\sigma(d_{i})$.}
          \end{equation}
    \item As a collection of relations, $\mathfrak{M}$ satisfies $\phi$.
  \end{enumerate}
\end{definition}

\begin{example}
  Let $\phi$ be as in \cref{example:first} and let
  $\sigma(\Gamma) = \sigma(\Delta) = 2$. Then the right-hand side of
  \cref{eq:subset} becomes
  \[
    [\sigma(\Gamma)] \times [\sigma(\Delta)] = [2] \times [2] = \{\,(1, 1), (1, 2), (2, 1), (2, 2)\,\}
  \]
  There are $2^{4} = 16$ possible relations between $\Gamma$ and $\Delta$. Let
  us count how many of them satisfy the conditions imposed on predicate
  $\texttt{p}$. The empty relation does. All four relations of cardinality one
  do too. Finally, there are two relations of cardinality two that satisfy the
  conditions as well. Thus, the FOMC of $(\phi, \sigma)$ is 7. Incidentally, it
  counts partial injections. We will continue to use the problem of counting
  partial injections (and the formula from \cref{example:first} specifically) as
  the main running example throughout the paper.
\end{example}

\section{From Circuits to Graphs}\label{sec:methods}

\begin{figure}[t]
  \centering
  \begin{forest}
    for tree={s sep=10mm, sn edges}
    [$\bigwedge_{x \in \Delta}$,ellipse,draw,label=right:{\color{blue}{$3^{n}$}}
    [$\lor$,ellipse,draw,label=right:{\color{blue}{$2 + 1 = 3$}}
    [$\land$,ellipse,draw,label=left:{\color{blue}{$2 \times 1 = 2$}}
    [$p(x) \lor \neg p(x)$,rectangle,draw,fill=gray!25,label=below:{\color{blue}{2}}]
    [$\land$,ellipse,draw,label={[label distance=0cm,text=blue]87:$1 \times 1 = 1$}
    [$q(x)$,rectangle,draw,fill=gray!25,label=below:{\color{blue}{1}}]
    [$\top$,rectangle,draw,fill=gray!25,label=below:{\color{blue}{1}}]
    ]
    ]
    [$\land$,ellipse,draw,label=right:{\color{blue}{$1 \times 1 = 1$}}
    [$\neg q(x)$,rectangle,draw,fill=gray!25,label=below:{\color{blue}{1}}]
    [$p(x)$,rectangle,draw,fill=gray!25,label=below:{\color{blue}{1}}]
    ]
    ]
    ]
  \end{forest}
  \caption{A circuit produced by \textsc{ForcLift} for \cref{example:simple}.
    Values and computations in blue (on the outside of each node) show how a
    bottom-up evaluation of the circuit computes the model
    count.}\label{fig:simplecircuit}
\end{figure}

Darwiche~\shortcite{DBLP:journals/jancl/Darwiche01} introduced
\emph{deterministic decomposable negation normal form} (d-DNNF) circuits for
propositional knowledge compilation and showed that the model count of a
propositional formula can be computed in time linear in the size of the circuit.
Van den Broeck et al.~\shortcite{DBLP:conf/ijcai/BroeckTMDR11} generalised them
to FOL via \emph{first-order d-DNNF (FO d-DNNF) circuits}. FO d-DNNF circuits
(hereafter simply called \emph{circuits}) are directed acyclic graphs with nodes
corresponding to formulas in FOL---see \cref{fig:simplecircuit} for an example.
The following types of nodes are supported by \textsc{ForcLift}: caching
($\Reff$), contradiction ($\bot$), tautology ($\top$), decomposable conjunction
($\land$), decomposable set-conjunction ($\bigwedge$), deterministic disjunction
($\lor$), deterministic set-disjunction ($\bigvee$), domain recursion,
grounding, inclusion-exclusion, smoothing, and unit clause. We refer the reader
to previous work~\cite{DBLP:conf/nips/Broeck11,DBLP:conf/ijcai/BroeckTMDR11} for
more information about node types and their interpretations for computing the
(W)FOMC\@.

\begin{figure}[t]
  \centering
  \begin{forest}
    for tree={sn edges}
    [$\GDR_{\Gamma \gets \Gamma \setminus \{\, x \,\}}$,ellipse,draw,name=gdr
    [$\bigvee_{\Delta^\top \subseteq \Delta}$,ellipse,draw
    [$\CR_{\Gamma \mapsto \Gamma'}$,ellipse,draw
    [$\land$,ellipse,draw
    [$\bot$,rectangle,draw,fill=gray!25]
    [$\Reff_{\{\, \Gamma \mapsto \Gamma', \Delta \mapsto \Delta^{\bot} \,\}}$,ellipse,draw,name=ref]
    ]
    ]
    ]
    ]
    \draw[-Latex,bend right=45] (ref) to (gdr);
  \end{forest}
  \caption{A simplified version of the FCG constructed by \textsc{Crane} for the
    problem of counting partial injections from \cref{example:first}. Here we
    omit some parameters as well as nodes whose only arithmetic effect is
    multiplication by one.}\label{fig:examplefcg}
\end{figure}

In this paper, we introduce \emph{FO d-DNNF computational graphs} (FCGs) that
generalise circuits by dispensing with acyclicity. Formally, an FCG is a (weakly
connected) directed graph with a single source, node labels, and ordered
outgoing edges. Node labels consist of two parts: the \emph{type} and the
\emph{parameters}. The type of a node determines its out-degree. We make the
following changes and additions to the node types already supported by
\textsc{ForcLift}. First, we introduce a new node type for constraint removal
($\CR$). Second, we replace domain recursion with generalised domain recursion
($\GDR$). And third, for reasoning about partially-constructed FCGs, we write
$\star$ for a placeholder type that is yet to be replaced. Similarly to Van den
Broeck et al.~\shortcite{DBLP:conf/ijcai/BroeckTMDR11}, we write $T_p$ for an
FCG that has a node with the label $T_p$ (i.e., type $T$ and parameter(s) $p$)
and $\star$'s as all of its direct successors. See \cref{fig:examplefcg} for an
example FCG\@. Its source node has out-degree 1, label
$\GDR_{\Gamma \gets \Gamma \setminus \{\, x \,\}}$, and type $\GDR$.

% Connecting FCGs with formulas
Finally, we introduce a structure that represents a solution to a (W)FOMC
problem while it is still being built. A \emph{chip} is a pair $(G, L)$, where
$G$ is an FCG, and $L$ is a list of formulas, s.t. $|L|$ is equal to the number
of $\star$'s in $G$. $L$ contains formulas that still need to be compiled. Once
a formula is compiled, it replaces one of the $\star$'s in $G$ according to a
set order. We say that an FCG is \emph{complete} (i.e., it represents a
\emph{complete solution}) if it has no $\star$'s. Similarly, a chip is complete
if its FCG is complete (or, equivalently, the list of formulas is empty).

\section{New Compilation Rules}\label{sec:rules}

A \emph{(compilation) rule} takes a formula and returns a set of chips. The
cardinality of this set is the number of different ways in which the rule can be
applied to the input formula. While
\textsc{ForcLift}~\cite{DBLP:conf/ijcai/BroeckTMDR11} heuristically chooses one
of them, in an attempt to not miss a solution, \textsc{Crane} returns them all.
In particular, if a rule returns an empty set, then that rule does not apply to
the formula.

\subsection{Generalised Domain Recursion}\label{sec:dr}

% Main idea
The main idea behind domain recursion (both the original version by Van den
Broeck~\shortcite{DBLP:conf/nips/Broeck11} and the one presented here) is as
follows. Let $\Omega \in \mathcal{D}$ be a domain. Assuming that
$\Omega \ne \emptyset$, pick some $x \in \Omega$. Then, for every variable
$X \in \Omega$ that occurs in a literal, consider two possibilities: $X = x$ and
$X \ne x$.

\begin{example}\label{example:dr}
  Let $\phi$ be a formula with a single clause
  \begin{multline*}
    (\{\, \neg \texttt{p}(X, Y), \neg \texttt{p}(X, Z) \,\}, \{\, (Y, Z) \,\}, \\
    \{\, X \mapsto \Gamma, Y \mapsto \Delta, Z \mapsto \Delta \,\}).
  \end{multline*}
  Then we can introduce constant $x \in \Gamma$ and rewrite $\phi$ as
  $\phi' = \{\, c_{1}, c_{2} \,\}$, where
  \begin{align*}
    c_{1} &= \begin{multlined}[t]
      (\{\, \neg \texttt{p}(x, Y), \neg \texttt{p}(x, Z) \,\}, \{\, (Y, Z) \,\}, \\
      \{\, Y \mapsto \Delta, Z \mapsto \Delta \,\}),
      \end{multlined}\\
    c_{2} &= \begin{multlined}[t]
      (\{\, \neg \texttt{p}(X, Y), \neg \texttt{p}(X, Z) \,\}, \{\, (X, x), (Y, Z) \,\}, \\
      \{\, X \mapsto \Gamma', Y \mapsto \Delta, Z \mapsto \Delta \,\}),
      \end{multlined}
  \end{align*}
  and $\Gamma' = \Gamma \setminus \{\, x \,\}$.
\end{example}

% Original domain recursion
Van den Broeck~\shortcite{DBLP:conf/nips/Broeck11} imposes stringent conditions
on the input formula to ensure that the expanded version of the formula (as in
\cref{example:dr}) can be handled efficiently. For instance,
\cref{example:first} cannot be handled by \textsc{ForcLift} because there is no
root binding class, i.e., the two root variables belong to different equivalence
classes with respect to the binding relationship. The clauses in this expanded
formula are then partitioned into three parts based on whether the
transformation introduced constants or constraints or both. The aforementioned
conditions ensure that these parts can be treated independently.

\begin{algorithm}[t]
  \caption{The compilation rule for $\GDR$ nodes.}\label{alg:domainrecursion}
  \KwIn{formula $\phi$, set of all relevant domains $\mathcal{D}$}
  \KwOut{set of chips $S$}
  $S \gets \emptyset$\;
  \ForEach{domain $\Omega \in \mathcal{D}$ s.t.\ there is $c \in \phi$ and $X \in \Vars(L_c)$ s.t. $\delta_c(X) = \Omega$\label{line:condition}}{
    $\phi' \gets \emptyset$\;
    $x \gets \text{a new constant in domain } \Omega$\;\label{line:constant}
    \ForEach{clause $c = (L, C, \delta) \in \phi$\label{line:forclause}}{
      $V \gets \{\, X \in \Vars(L) \mid \delta(X) = \Omega \,\}$\;\label{line:V}
      \ForEach{$W \subseteq V$ s.t. $W^2 \cap C = \emptyset$ {\bf and} $W \cap \{\, X \in \Vars(C) \mid (X, y) \in C \text{ for some constant } y \,\} = \emptyset$\label{line:conditions}}{
        \tcc{$\delta'$ restricts $\delta$ to the new set of variables}
        $\phi' \gets \phi' \cup \{\, (L[x/W], C[x/W] \cup \{\, (X, x) \mid (X \in V \setminus W) \,\}, \delta') \,\}$\;\label{line:generation}
      }
    }
    $S \gets S \cup \{\, (\GDR_{\Omega \gets \Omega \setminus \{\, x \,\}}, \langle\phi'\rangle) \,\}$\;
  }
\end{algorithm}

% Description of GDR, in contrast to DR
In contrast, GDR has only one precondition: for GDR to be applicable on domain
$\Omega \in \mathcal{D}$, there must be at least one variable with domain
$\Omega$ that is featured in a literal (and not just in constraints). Without
such variables, GDR would have no effect on the formula. GDR is also simpler in
that the expanded formula is left as-is to be handled by other compilation
rules. Typically, after a few more rules are applied, a combination of $\CR$ and
$\Reff$ nodes introduces a cycle-inducing edge back to the $\GDR$ node, thus
completing the definition of a recursive function. The GDR compilation rule is
summarised as \cref{alg:domainrecursion} and explained in more detail using the
example below.

\begin{example}
  Let $\phi \coloneqq \{\, c_1, c_2 \,\}$ be the formula from
  \cref{example:first}. While GDR is possible on both domains, here we
  illustrate how it works on $\Gamma$. Having chosen a domain, the algorithm
  iterates over the clauses of $\phi$. Suppose \cref{line:forclause} picks
  $c = c_1$ as the first clause. Then, set $V$ is constructed to contain all
  variables with domain $\Omega = \Gamma$ that occur in the literals of clause
  $c$. In this case, $V = \{\, X \,\}$.

  \Cref{line:conditions} iterates over all subsets $W \subseteq V$ of variables
  that can be replaced by a constant without resulting in evidently
  unsatisfiable formulas. We impose two restrictions on $W$. First,
  $W^2 \cap C = \emptyset$ ensures that there are no pairs of variables in $W$
  that are constrained to be distinct, since that would result in an $x \ne x$
  constraint after substitution. Similarly, we want to avoid variables in $W$
  that have inequality constraints with constants: after the substitution, such
  constraints would transform into inequality constraints between two constants.
  In this case, both subsets of $V$ satisfy these conditions, and
  \cref{line:generation} generates two clauses for the output formula:
  \begin{multline*}
    (\{\, \neg \texttt{p}(X, Y), \neg \texttt{p}(X, Z) \,\}, \{\, (Y, Z), (X, x) \,\}, \\
    \{\, X \mapsto \Gamma, Y \mapsto \Delta, Z \mapsto \Delta \,\}),
  \end{multline*}
  from $W = \emptyset$ and
  \[
    (\{\, \neg \texttt{p}(x, Y), \neg \texttt{p}(x, Z) \,\}, \{\, (Y, Z) \,\}, \{\, Y \mapsto \Delta, Z \mapsto \Delta \,\})
  \]
  from $W = V$.

  When \cref{line:forclause} picks $c = c_2$, then $V = \{\, X, Z \,\}$. The
  subset $W = V$ fails to satisfy the conditions on \cref{line:conditions}
  because of the $X \ne Z$ constraint. The other three subsets of $V$ all
  generate clauses for $\phi'$. Indeed, $W = \emptyset$ generates
  \begin{multline*}
    (\{\, \neg \texttt{p}(X, Y), \neg \texttt{p}(Z, Y) \,\}, \{\, (X, Z), (X, x), (Z, x) \,\}, \\
    \{\, X \mapsto \Gamma, Y \mapsto \Delta, Z \mapsto \Gamma \,\}),
  \end{multline*}
  $W = \{\, X \,\}$ generates
  \[
    (\{\, \neg \texttt{p}(x, Y), \neg \texttt{p}(Z, Y) \,\}, \{\, (Z, x) \,\}, \{\, Y \mapsto \Delta, Z \mapsto \Gamma \,\}),
  \]
  and $W = \{\, Z \,\}$ generates
  \[
    (\{\, \neg \texttt{p}(X, Y), \neg \texttt{p}(x, Y) \,\}, \{\, (X, x) \,\}, \{\, X \mapsto \Gamma, Y \mapsto \Delta \,\}).
  \]
\end{example}

\begin{theorem}[Correctness of $\GDR$\footnote{\Cref{thm:correctness1} is equivalent to
    Proposition~3 by Van den Broeck~\shortcite{DBLP:conf/nips/Broeck11}.}]\label{thm:correctness1}
  Let $\phi$ be the formula used as input to \cref{alg:domainrecursion},
  $\Omega \in \mathcal{D}$ the domain selected on \cref{line:condition}, and
  $\phi'$ the formula constructed by the algorithm for $\Omega$. Assume that
  $\Omega \ne \emptyset$. Then $\phi \equiv \phi'$.
\end{theorem}
\begin{proof}
  Let $x$ be the constant introduced on \cref{line:constant} and $c$ a clause of
  $\phi$ selected on \cref{line:forclause} of the algorithm. We will show that
  $c$ is equivalent to the conjunction of clauses added to $\phi'$ on
  \cref{line:conditions,line:generation}.

  If $c$ has no variables with domain $\Omega$, then
  \cref{line:conditions,line:generation} simply add a copy of $c$ to $\phi'$. If
  $c$ has one variable with domain $\Omega$, say, $X$, then
  $c \equiv \forall X \in \Omega\text{. } \psi$ for some formula $\psi$ with one
  free variable $X$. In this case, \cref{line:conditions,line:generation} create
  two clauses: $\psi[x/\{\, X \,\}]$ and $\forall X \in \Omega\text{.
  } X \ne x \Rightarrow \psi$. It is easy to see that their conjunction is
  equivalent to $c$ provided that $\Omega \ne \emptyset$ and so $x$ is a
  well-defined constant.

  Let $V$ be the set of variables introduced on \cref{line:V}. It remains to
  show that repeating the transformation
  \[
    \forall X \in \Omega\text{. } \psi \mapsto \{\, \psi[x/\{\, X \,\}], \forall X \in \Omega\text{. } X \ne x \Rightarrow \psi \,\}
  \]
  for all variables $X \in V$ produces the same clauses as
  \cref{line:conditions,line:generation} (except for some tautologies that the
  latter method skips). Note that the order in which these operations are
  applied is immaterial. In other words, if we add inequality constraints for
  variables ${\{\, X_{i} \,\}}_{i=1}^{n}$, and apply substitution for variables
  $V \setminus {\{\, X_{i} \,\}}_{i=1}^{n}$, then---regardless of the order of
  operations---we get
  \[
    \forall X_{1}, \dots, X_{n} \in \Omega\text{.} \bigwedge_{i=1}^{n} X_{i} \ne x \Rightarrow \psi\left[x / \left(V \setminus {\{\, X_{i} \,\}}_{i=1}^{n}\right)\right].
  \]
  This formula is equivalent to the clause generated on \cref{line:generation}
  with $W = V \setminus {\{\, X_{i} \,\}}_{i=1}^{n}$. Thus, for every clause $c$
  of $\phi$, the new formula $\phi'$ gets a set of clauses whose conjunction is
  equivalent to $c$. Hence, the two formulas are equivalent.
\end{proof}

\subsection{Constraint Removal}\label{sec:cr}

Recall that GDR on a domain $\Omega$ creates constraints of the form $X_i \ne x$
for some constant $x \in \Omega$ and family of variables $X_i \in \Omega$. Once
certain conditions are satisfied, we can eliminate these constraints and replace
$\Omega$ with a new domain $\Omega'$, which can be interpreted as
$\Omega \setminus \{\, x \,\}$. These conditions are that a constraint of the
form $X \ne x$ exists for all variables $X \in \Omega$ across all clauses, and
such constraints are the only place where $x$ occurs. We formalise the
conditions as \cref{def:replaceable}.

\begin{definition}\label{def:replaceable}
  With respect to a formula $\phi$, a pair $(\Omega, x)$ of a domain
  $\Omega \in \mathcal{D}$ and its element $x \in \Omega$ is called
  \emph{replaceable} if
  \begin{itemize}
    \item $x$ does not occur in any literal of any clause of $\phi$,
    \item and for each clause $c = (L, C, \delta_c) \in \phi$ and variable
          $X \in \Vars(c)$, either $\delta_c(X) \ne \Omega$ or $(X, x) \in C$.
  \end{itemize}
\end{definition}

\begin{algorithm}[t]
  \caption{The compilation rule for $\CR$ nodes.}\label{alg:constraintremoval}
  \KwIn{formula $\phi$, set of all relevant domains $\mathcal{D}$}
  \KwOut{set of chips $S$}
  $S \gets \emptyset$\;
  \ForEach{replaceable pair $(\Omega \in \mathcal{D}, x \in \Omega)$\label{line:crconditions}}{
    add a new domain $\Omega'$ to $\mathcal{D}$\;\label{line:newdomain}
    $\phi' \gets \emptyset$\;
    \ForEach{clause $(L, C, \delta) \in \phi$}{
      $C' \gets \{\, (a, b) \in C \mid b \ne x \,\}$\;\label{line:constraintremoval}
      \nosemic$\delta' \gets X \mapsto
      \begin{cases}
        \Omega' & \text{if } \delta(X) = \Omega\\
        \delta(X) & \text{otherwise;}
      \end{cases}$\;\label{line:newdelta}
      $\phi' \gets \phi' \cup \{\, (L, C', \delta') \,\}$\;
    }
    $S \gets S \cup \{\, (\CR_{\Omega \mapsto \Omega'}, \langle\phi'\rangle) \,\}$\;
  }
\end{algorithm}

Once a replaceable pair is found, \cref{alg:constraintremoval} proceeds to
construct the new formula by removing constraints (on
\cref{line:constraintremoval}) and constructing a new domain map $\delta'$ that
replaces $\Omega$ with $\Omega'$ (on \cref{line:newdelta}).

\begin{example}
  Let $\phi = \{\, c_1, c_2 \,\}$ be a formula with clauses
  \begin{align*}
    c_1 &=
          \begin{multlined}[t]
            (\{\, \neg \texttt{p}(X, Y), \neg \texttt{p}(X, Z) \,\}, \{\, (X, x), (Y, Z) \,\}, \\
            \{\, X \mapsto \Gamma, Y \mapsto \Delta, Z \mapsto \Delta \,\}),
          \end{multlined}\\
    c_2 &=
          \begin{multlined}[t]
            (\{\, \neg \texttt{p}(X, Y), \neg \texttt{p}(Z, Y) \,\}, \\
            \{\, (X, x), (Z, X), (Z, x) \,\}, \\
            \{\, X \mapsto \Gamma, Y \mapsto \Delta, Z \mapsto \Gamma \,\}).
          \end{multlined}
  \end{align*}
  Domain $\Gamma$ and its element $x \in \Gamma$ satisfy the preconditions for
  CR\@. The rule introduces a new domain $\Gamma'$ and transforms $\phi$ to
  $\phi' = (c_1', c_2')$, where
  \begin{align*}
    c_1' &=
           \begin{multlined}[t]
             (\{\, \neg \texttt{p}(X, Y), \neg \texttt{p}(X, Z) \,\}, \{\, (Y, Z) \,\}, \\
             \{\, X \mapsto \Gamma', Y \mapsto \Delta, Z \mapsto \Delta \,\}),
           \end{multlined} \\
    c_2' &=
           \begin{multlined}[t]
             (\{\, \neg \texttt{p}(X, Y), \neg \texttt{p}(Z, Y) \,\}, \{\, (Z, X) \,\}, \\
             \{\, X \mapsto \Gamma', Y \mapsto \Delta, Z \mapsto \Gamma' \,\}).
           \end{multlined}
  \end{align*}
\end{example}

\begin{theorem}[Correctness of $\CR$]
  Let $\phi$ be the input formula of \cref{alg:constraintremoval}, $(\Omega, x)$
  a replaceable pair, and $\phi'$ the formula constructed by the algorithm, when
  $(\Omega, x)$ is selected on \cref{line:crconditions}. Then
  $\phi \equiv \phi'$, where the domain $\Omega'$ introduced on
  \cref{line:newdomain} is interpreted as $\Omega \setminus \{\, x \,\}$.
\end{theorem}
\begin{proof}
  Since there is a natural bijection between the clauses of $\phi$ and $\phi'$,
  we shall argue about the equivalence of each pair of clauses. Let $c$ be an
  arbitrary clause of $\phi$ and $c'$ its corresponding clause of $\phi'$.

  If $c$ has no variables with domain $\Omega$, then it cannot have any
  constraints involving $x$, so $c' = c$. Otherwise, for notational simplicity,
  let us assume that $X$ is the only variable in $c$ with domain $\Omega$ (the
  proof for an arbitrary number of variables is virtually the same). By
  \cref{def:replaceable}, we can rewrite $c$ as $\forall X \in \Omega\text{.
  } X \ne x \Rightarrow \psi$, where $\psi$ is a formula with $X$ as the only free
  variable and with no mention of either $x$ or $\Omega$. Then
  $c' \equiv \forall X \in \Omega'\text{. } \psi$. Since
  $\Omega' \coloneqq \Omega \setminus \{\, x \,\}$, we have that $c \equiv c'$.
  Since $c$ was an arbitrary clause of $\phi$, this completes the proof that
  $\phi \equiv \phi'$.
\end{proof}

\subsection{Identifying Opportunities for Recursion}\label{sec:ref}

\paragraph{Hashing.}
We use (integer-valued) hash functions to discard pairs of formulas that are too
different for recursion to work. The hash code of a clause
$c = (L, C, \delta_{c})$ (denoted by $\# c$) combines the hash codes of the sets
of constants and predicates in $c$, the numbers of positive and negative
literals, the number of inequality constraints $|C|$, and the number of
variables $|\Vars(c)|$. The hash code of a formula $\phi$ combines the hash
codes of all its clauses and is denoted by $\#\phi$.

\paragraph{Caching.}
\textsc{ForcLift}~\cite{DBLP:conf/ijcai/BroeckTMDR11} uses a cache to check if
a formula is identical to one of the formulas that have already been fully
compiled. To facilitate recursion, we extend the caching scheme to include
formulas that have been encountered but not fully compiled yet. Formally, we
define a \emph{cache} to be a map from integers (e.g., hash codes) to sets of
pairs of the form $(\phi, v)$, where $\phi$ is a formula, and $v$ is an FCG
node.

\begin{algorithm}[t]
  \caption{The compilation rule for $\Reff$ nodes.}\label{alg:trycache}
  \KwIn{formula $\phi$, cache $C$}
  \KwOut{a set of chips}

  \ForEach{formula and node $(\psi, v) \in C(\#\phi)$}{\label{line:selectformula}
    $\rho \gets \identifyRecursion{$\phi$, $\psi$}$\;
    \lIf{$\rho \ne {\normalfont \texttt{null}}$}{\Return{$\{\, (\Reff_\rho(v), \langle\rangle) \,\}$}}\label{line:rho}
  }
  \Return{$\emptyset$}\;

  \Fn{\identifyRecursion{formula $\phi$, formula $\psi$, map $\rho = \emptyset$}}{
    \lIf{$|\phi| \ne |\psi|$ {\bf or} $\#\phi \ne \#\psi$}{\Return{\normalfont\texttt{null}}}
    \lIf{$\phi = \emptyset$}{\Return{$\rho$}}
    \ForEach{clause $c \in \psi$\label{line:for1}}{
      \ForEach{clause $d \in \phi$ s.t. $\#d=\#c$\label{line:for2}}{
        \ForAll{$\gamma \in \generateMaps{$c$, $d$, $\rho$}$\label{line:generateMaps}}{
          $\rho' \gets \identifyRecursion{$\phi\setminus\{\, d \,\}$, $\psi\setminus\{\, c \,\}$, $\rho\cup\gamma$}$\;\label{line:recursion}
          \lIf{$\rho' \ne {\normalfont \texttt{null}}$}{\Return{$\rho'$}}
        }
      }
      \Return{\normalfont\texttt{null}}\;
    }
  }
\end{algorithm}

% Cache $C$ is used to partition all previously-encountered formulas based on
% their hash codes.
\Cref{alg:trycache} describes the compilation rule for creating $\Reff$ nodes.
For every formula $\psi$ in the cache s.t. $\#\psi = \#\phi$, function
\texttt{r} is called to check whether a recursive call is feasible. If it is,
\texttt{r} returns a (total) map $\rho\colon \Doms(\psi) \to \Doms(\phi)$ that
shows how $\psi$ can be transformed into $\phi$ by replacing each domain
$\Omega \in \Doms(\psi)$ with $\rho(\Omega) \in \Doms(\phi)$. Otherwise,
\texttt{r} returns \texttt{null} to signify that $\phi$ and $\psi$ are too
different for recursion to work. This happens if $\phi$ and $\psi$ (or their
subformulas explored in recursive calls) are structurally different (i.e., the
numbers of clauses or the hash codes fail to match) or if a clause of $\psi$
cannot be paired with a sufficiently similar clause of $\phi$. Function
\texttt{r} works by iterating over pairs of clauses of $\phi$ and $\psi$ that
have the same hash codes. For every pair of sufficiently similar clauses,
\texttt{r} calls itself on the remaining clauses until the map
$\rho\colon \Doms(\psi) \pfun \Doms(\phi)$ becomes total, and all clauses are
successfully coupled.

Function \texttt{genMaps} checks the compatibility of a pair of clauses. It
considers every possible bijection $\beta\colon \Vars(c) \to \Vars(d)$ and map
$\gamma\colon \Doms(c) \to \Doms(d)$ s.t.
\[
  \begin{tikzcd}
    \Vars(c) \ar[r, dashed, "\beta"] \arrow[d, swap, "\delta_c"] & \Vars(d) \ar[d, "\delta_d"] \\
    \Doms(c) \ar[r, dashed, "\gamma"] \ar[d, hookrightarrow] & \Doms(d) \ar[d, hookrightarrow] \\
    \Doms(\psi) \ar[r, swap, "\rho", "|" marking, outer sep=5pt] & \Doms(\phi).
  \end{tikzcd}
\]
commutes, and $c$ becomes equal to $d$ when its variables are replaced according
to $\beta$ and its domains replaced according to $\gamma$. The function then
returns each such $\gamma$ as soon as possible. The commutativity check also
ensures that $\rho \cup \gamma$ is possible on \cref{line:recursion} of
\cref{alg:trycache}. The resulting (partial) function $\rho \cup \gamma$ is the
unique function s.t. $\rho \cup \gamma|_{\dom(\rho)} = \rho$, and
$\rho \cup \gamma|_{\dom(\gamma)} = \gamma$. The operation is defined when
$\rho|_{\dom(\rho)\cap\dom(\gamma)} = \gamma|_{\dom(\rho)\cap\dom(\gamma)}$.

\begin{theorem}[Correctness of $\Reff$]
  Let $\phi$ be the formula used as input to \cref{alg:trycache}. Let $\psi$ be
  any formula selected on \cref{line:selectformula} of the algorithm such that
  $\rho \ne {\normalfont\texttt{null}}$ on \cref{line:rho}. Let $\sigma$ be a
  domain size function. Then the set of models of $(\psi, \sigma \circ \rho)$ is
  equal to the set of models of $(\phi, \sigma)$.
\end{theorem}
\begin{proof}
  We first show that the right-hand side of \cref{eq:subset} is the same for
  models of both $(\phi, \sigma)$ and $(\psi, \sigma \circ \rho)$.
  \Cref{alg:trycache} ensures that $\psi \equiv \phi$ up to domains. In
  particular, this means that $\Preds(\psi) = \Preds(\phi)$. The square in
  \begin{equation}\label[diagram]{diagram:ref}
    \begin{tikzcd}
      \Preds(\psi) \ar[equal]{r} \ar[d, swap, "\pi_{\psi}"] & \Preds(\phi) \ar[d, "\pi_{\phi}"] \\
      {\Doms(\psi)}^{\ast} \ar[r, "\rho"] & {\Doms(\phi)}^{\ast} \ar[r, "\sigma"] & \mathbb{N}_{0}^{\ast}
    \end{tikzcd}
  \end{equation}
  commutes by \cref{def:formula} and the definition of $\rho$. In other words,
  for any predicate $\texttt{p}/n \in \Preds(\psi) = \Preds(\phi)$, function
  $\rho$ translates the domains associated with $\texttt{p}$ in $\psi$ to the
  domains associated with $\texttt{p}$ in $\phi$. Let
  $\pi_{\phi}(\texttt{p}) = {(d_{i})}_{i=1}^{n}$ and
  $\pi_{\psi}(\texttt{p}) = {(e_{i})}_{i=1}^{n}$ for some domains
  $d_{i} \in \Doms(\phi)$ and $e_{i} \in \Doms(\psi)$. Since
  $\rho(e_{i}) = d_{i}$ for all $i = 1, \dots, n$ by the commutativity in
  \cref{diagram:ref}, we get that
  \begin{equation}\label{eq:equality}
    \prod_{i=1}^{n}[\sigma(d_{i})] = \prod_{i=1}^{n}[\sigma \circ \rho(e_{i})]
  \end{equation}
  as required. Certainly, any subset of the left-hand side of \cref{eq:equality}
  (e.g., $\mathfrak{M}(\texttt{p})$, where $\mathfrak{M}$ is a model of
  $(\phi, \sigma)$) is a subset of the right-hand side and vice versa. Since
  $\phi$ and $\psi$ semantically only differ in what domains they refer to,
  every model of $\phi$ satisfies $\psi$ and vice versa, completing the proof.
\end{proof}

\section{How to Interpret an FCG}\label{sec:interpret}

\begin{algorithm}[t]
  \caption{Construct functions from an FCG}
  \SetKwProg{Fn}{Function}{:}{}

  \SetKwData{domains}{domains}
  \SetKwData{functionCall}{call}
  \SetKwData{functionSignature}{signature}
  \SetKwData{functionNames}{F}
  \SetKwData{variableNames}{V} % TODO: mathcal? Same for function names?
  \SetKwData{newVariableNames}{V'}
  \SetKwData{expression}{e}
  \SetKwData{functions}{funs}

  \SetKwFunction{newFunctionName}{newFunctionName}
  \SetKwFunction{newVariableName}{newVarName}
  \SetKwFunction{visit}{visit}
  \SetKwFunction{actuallyVisit}{actuallyVisit}

  \KwIn{$\mathcal{D}$---the set of domains of the input formula}
  \KwIn{$s$---the source of the FCG}
  \KwData{$\functionNames = \emptyset$}
  \KwOut{a list of Strings, each defining a function (the top one is the main one)}
  $\variableNames \gets \{\, d \mapsto \newVariableName{} \mid d \in \mathcal{D} \,\}$\;
  \uIf{$s$ is a direct successor of a $\Reff$ node}{
    $(\expression, \functions) \gets \visit{$s$, $\variableNames$}$\;
    \Return{\functions}\;
  }
  \Else{
    $f \gets \newFunctionName{$s$}$\;
    $(\expression, \functions) \gets \visit{$s$, $\variableNames$}$\;
    \Return{$\langle f(\langle \variableNames{$d$} \mid d \in \mathcal{D} \rangle) = \expression \rangle + \functions$}\;
  }
  \Fn{\visit{node $v$, \variableNames}}{
    \If{$v$ is not a direct successor of a $\Reff$ node}{ % TODO: boldface the NOT
      \Return{\actuallyVisit{$v$, \variableNames}}\;
    }
    $f \gets \newFunctionName{$v$}$\;
    $\newVariableNames \gets \{\, \text{if } d \in v.\domains \text{ and } n \text{ contains subtraction then } d \mapsto \newVariableName{} \text{ else } d \mapsto n \mid d \mapsto n \in \variableNames \,\}$\;
    $(\expression, \functions) \gets \actuallyVisit{$v$, \newVariableNames}$\;
    $\functionCall \gets f(\langle \variableNames{$d$} \mid d \in v.\domains \rangle)$\;
    $\functionSignature \gets f(\langle \newVariableNames{$d$} \mid d \in v.\domains \rangle)$\;
    \Return{$(\functionCall, \langle \functionSignature = \expression \rangle + \functions)$}\;
  }
  \Fn{\actuallyVisit{node $v$, \variableNames}}{
    \Switch{type of $v$}{
      \uCase{$\Reff_{\rho}(v')$}{
        \Return{$(\functionNames{$v'$}(\langle \variableNames{$\rho(d)$} \mid d \in v'.\domains \rangle), \langle \rangle)$}\;
      }
      \lCase{$\GDR(v')$}{\Return{\visit{$v'$, \variableNames}}}
      \uCase{$\CR_{d,d'}(v')$}{\Return{\visit{$v'$, $\variableNames \cup \{\, d' \mapsto (\variableNames(d) - 1) \,\}$}}\;}
      \dots
    }
  }
\end{algorithm}
% TODO: introduce symbol for list concatenation (4 places)
% 'is a direct successor of a Ref node' = the in-degree is > 1
% TODO: check if the distinction between data and function is appropriate and that all function calls use the right {} syntax
% TODO: DeclareMathOperator for Or, etc.
% TODO: check if all semicolons are there

\begin{itemize}
  \item for each node v, v.domains is a precomputed set of domains that are used
        by v and all of its successors (except the ones that are introduced by v
        or its successors) (this was already part of ForcLift, although had to
        be reimplemented in a way that avoids infinite loops when dealing with
        cycles in graphs)
  \item NOTE: for list generators over a set of domains, we assume an arbitrary
        fixed ordering over all domains
  \item functionNames is a partial map (initially empty) from the set of nodes
        of the FCG to Strings
  \item newVariableName() just generates a unique identifier for a variable
  \item newFunctionName(node n) does the same thing for function names and also
        records the new name in functionNames
\end{itemize}

When \textsc{ForcLift}~\cite{DBLP:conf/ijcai/BroeckTMDR11} compiles a WFOMC
instance into a circuit, each node type encodes an arithmetic operation on its
inputs and parameters. These operations are then immediately performed while
traversing the circuit. With \textsc{Crane}, the interpretation of an FCG is a
collection of functions. Each function has (some) domain sizes as parameters and
may contain recursive calls to other functions, including itself. While there
may be any number of subsidiary functions, there is always one main function
that can be called with the sizes of the domains of the input formula as
arguments. Henceforth, this function is always called $f$, and it is defined by
the source node.

The interpretation of a node is decided by its type. Here we describe the
interpretations of new (or significantly changed) types and refer the reader to
previous work~\cite{DBLP:conf/ijcai/BroeckTMDR11} for information on other
types. The interpretation of a $\CR$ or a $\GDR$ node is simply the
interpretation of its only direct successor. Obviously, $\star$ nodes have no
interpretation as incomplete FCGs are not meant to be interpreted. The
interpretation of a $\Reff$ node is a function call. The direct successor of the
$\Reff$ node (say, $v$) then must introduce a function. The parameters of this
function are the sizes of all domains used by nodes reachable from $v$.

\begin{example}\label{example:interpretation}
  Consider the FCG from \cref{fig:examplefcg}. The input formula (i.e., the
  formula from \cref{example:first}) has two domains: $\Gamma$ and $\Delta$.
  Thus, the interpretation of the FCG is a function
  $f\colon \mathbb{N}_{0} \times \mathbb{N}_{0} \to \mathbb{R}_{\ge 0}$. Let
  $m \coloneqq |\Gamma|$, and $n \coloneqq |\Delta|$. The node labelled
  $\bigvee_{\Delta^{\top} \subseteq \Delta}$ tells us that
  $f(m, n) = \sum_{l = 0}^{n} \binom{n}{l} \square$, where $\square$ is the
  interpretation of the remaining subgraph, and $l$ iterates over all possible
  sizes of $\Delta^{\top}$. It also creates two subdomains
  $\Delta^{\top}, \Delta^{\bot} \subseteq \Delta$ that partition $\Delta$, i.e.,
  as the size of $\Delta^{\top}$ increases, the size of $\Delta^{\bot}$
  correspondingly decreases. Nodes labelled $\land$ correspond to
  multiplication. Therefore,
  $f(m, n) = \sum_{l = 0}^{n} \binom{n}{l} \diamondsuit \times \heartsuit$,
  where $\diamondsuit$ is the interpretation of the contradiction (i.e., $\bot$)
  node, and $\heartsuit$ is the interpretation of the $\Reff$ node.

  A contradiction node with clause $c$ as a parameter is interpreted as one if
  the clause has groundings and zero otherwise. In this case, the parameter is
  $c = (\emptyset, \{\, (X, Y) \,\}, \{\, X \mapsto \Delta^\top, Y \mapsto \Delta^\top \,\})$
  (not shown in \cref{fig:examplefcg}), which can be read as
  $\forall X, Y \in \Delta^{\top}\text{. }X \ne Y \Rightarrow \bot$, i.e.,
  $\forall X, Y \in \Delta^{\top}\text{. }X = Y$. This latter sentence is true
  if and only if $|\Delta^{\top}| < 2$. Therefore, we can use the Iverson
  bracket notation to write
  \[
    \diamondsuit = [l < 2] \coloneqq
    \begin{cases}
      1 & \text{if } l < 2 \\
      0 & \text{otherwise.}
    \end{cases}
  \]

  It remains to interpret the $\Reff$ node. Parameter
  $\{\, \Gamma \mapsto \Gamma', \Delta \mapsto \Delta^\bot \,\}$ tells us that
  the interpretation of the $\Reff$ node should be the same as that of the
  source node, but with domains $\Gamma$ and $\Delta$ replaced with $\Gamma'$
  and $\Delta^{\bot}$, respectively. Domain $\Gamma'$ was created by the CR rule
  applied on $\Gamma$, so $|\Gamma'| = m - 1$. Now
  $\Delta^{\bot} = \Delta \setminus \Delta^{\top}$, and $|\Delta^{\top}| = l$,
  so $|\Delta^{\bot}| = n - l$. Thus, the interpretation of the $\Reff$ node is
  a recursive call to $f(m - 1, n - l)$. Therefore,
  \begin{align}
    f(m, n) &= \sum_{l = 0}^{n} \binom{n}{l} [l < 2] f(m-1, n-l)\nonumber \\
            &= f(m-1, n) + n f(m-1, n-1).\label{eq:solution}
  \end{align}
  To use this recursive function to compute the model count of the input formula
  for any domain sizes, one just needs to find the base cases $f(0, n)$ and
  $f(m, 0)$ for all $m, n \in \mathbb{N}_{0}$.
\end{example}

\section{Experimental Results}\label{sec:results}

We compare \textsc{Crane} and
\textsc{ForcLift}\footnote{\url{https://dtaid.cs.kuleuven.be/wfomc}}~\cite{DBLP:conf/ijcai/BroeckTMDR11}
on their ability to count various kinds of functions. This class of instances is
chosen because of its simplicity and ubiquity and the inability of
state-of-the-art WFOMC algorithms to solve many such instances. Note that other
WFOMC algorithms mentioned in \cref{sec:introduction} are unable to solve any of
the instances that \textsc{ForcLift} fails on. We begin by describing how such
function-counting problems can be expressed in FOL\@. \textsc{ForcLift} then
translates these sentences in FOL to formulas as defined in \cref{def:formula}.

Let $\texttt{p}$ be a predicate that models relations between sets $\Gamma$ and
$\Delta$. To restrict all such relations to just $\Gamma \to \Delta$ functions,
in FOL one might write
\[
  \forall X \in \Gamma\text{. }\forall Y,Z \in \Delta\text{. }\texttt{p}(X, Y) \land \texttt{p}(X, Z) \Rightarrow Y = Z
\]
and
\begin{equation}\label{eq:def2}
  \forall X \in \Gamma\text{. }\exists Y \in \Delta\text{. }\texttt{p}(X, Y).
\end{equation}
The former sentence says that one element of $\Gamma$ can map to at \emph{most}
one element of $\Delta$, and the latter sentence says that each element of
$\Gamma$ must map to at \emph{least} one element of $\Delta$. One can then add
\[
  \forall X,Z \in \Gamma\text{. }\forall Y \in \Delta\text{. }\texttt{p}(X, Y) \land \texttt{p}(Z, Y) \Rightarrow X = Z
\]
to restrict $\texttt{p}$ to injections or
\[
  \forall Y \in \Delta\text{. }\exists X \in \Gamma\text{. }\texttt{p}(X, Y)
\]
to ensure surjectivity or remove \cref{eq:def2} to consider partial functions.
Lastly, one can replace all occurrences of $\Delta$ with $\Gamma$ to model
endofunctions (i.e., functions with the same domain and codomain) instead.

% the process: both for running algorithms and for determining complexities
In our experiments, we consider all sixteen combinations of these properties,
i.e., injectivity, surjectivity, partiality, and endo-. We run each algorithm
once on each of the sixteen instances.\footnote{While domain sizes have to be
  specified as part of the input, they are immaterial to the search procedure.}
\textsc{Crane} is run in hybrid search mode until either five solutions are
found or the search tree reaches height six. \textsc{ForcLift} is always run
until it terminates. If successful, \textsc{ForcLift} generates a circuit, and
\textsc{Crane} generates one or more (complete) FCGs. In both cases, we manually
convert the resulting graphs into definitions of functions as described in
\cref{sec:interpret}. We then assess the complexity of each solution by hand and
pick the best in case \textsc{Crane} returns several solutions of varying
complexities.

% \footnote{The search tree has a high
%   branching factor, so exploring all nodes at depth five takes at most a few
%   seconds, whereas doing the same for depth six can be computationally
%   infeasible in some cases.}

% how the complexity of a solution is determined
Previous work often compares WFOMC algorithms by running them on a few instances
with increasing domain sizes and measuring
runtime~\cite{DBLP:conf/nips/Broeck11,DBLP:conf/ijcai/BroeckTMDR11,DBLP:conf/aaai/BroeckD12}.
However, we can do much better and identify the exact worst-case asymptotic
complexity of a solution produced by either \textsc{Crane} or \textsc{ForcLift}.
The asymptotic complexity of a solution can be determined by considering the
total number of arithmetic operations needed to follow the definitions of
constituent functions without recomputing the same quantity multiple times. In
particular, we assume that each function call and binomial coefficient is
computed at most once. We also assume that computing $\binom{n}{k}$ takes
$\Theta(nk)$ time. For example, the complexity of \cref{eq:solution} is
$\Theta(mn)$ since $f(m, n)$ can be computed by a dynamic programming algorithm
that computes $f(i, j)$ for all $i = 0, \dots, m$ and $j = 0, \dots, n$, taking
a constant amount of time on the computation of each $f(i, j)$.

\begin{table*}[t]
  \centering
  \begin{tabular}{cccccc}
    \toprule
    \multicolumn{3}{c}{Function Class} & \multicolumn{3}{c}{Asymptotic Complexity of Counting} \\
    Partial & Endo- & Class & Best Known & With \textsc{ForcLift} & With \textsc{Crane} \\
    \midrule
    \rowcolor{gray!25}\cmark/\xmark & \cmark/\xmark & Functions & $\log m$ & $m$ & $m$ \\
    \xmark & \xmark & \multirow{4}{*}{Surjections} & $n \log m$ & $m^{3}+n^{3}$ & $m^{3}+n^{3}$ \\
    \xmark & \cmark & & $m \log m$ & $m^{3}$ & $m^{3}$ \\
    \cmark & \xmark & & \multicolumn{3}{c}{Same as injections from $\Delta$ to $\Gamma$} \\
    \cmark & \cmark & & \multicolumn{3}{c}{Same as endo-injections} \\
    \rowcolor{gray!25}\xmark & \xmark & & $m$ & --- & $mn$ \\
    \rowcolor{gray!25}\xmark & \cmark & & $m$ & --- & $m^3$ \\
    \rowcolor{gray!25}\cmark & \xmark & & ${\min\{\, m, n \,\}}^2$ & --- & $mn$ \\
    \rowcolor{gray!25}\cmark & \cmark & \multirow{-4}{*}{Injections} & $m^2$ & --- & --- \\
    \xmark & \xmark & \multirow{3}{*}{Bijections} & $m$ & --- & $m$ \\
    \xmark & \cmark & & \multicolumn{3}{c}{\multirow{2}{*}{Same as (partial) (endo-)injections}} \\
    \cmark & \cmark/\xmark & & \multicolumn{3}{c}{} \\
    \bottomrule
  \end{tabular}
  \caption{The worst-case complexity of counting various types of functions,
    where $m$ is the size of domain $\Gamma$, and $n$ is the size of domain
    $\Delta$. All asymptotic complexities are in $\Theta(\cdot)$. A dash means
    that the algorithm was not able to find a solution.}\label{tbl:results}
\end{table*}

The experimental results are summarised in \cref{tbl:results}, where we compare
the solutions found by both algorithms to the best known ways of computing the
same quantities. The best-known asymptotic complexity for computing total
surjections is by Earnest~\shortcite{30049}. All other best-known complexity
results are inferred from the formulas and programs on the on-line encyclopedia
of integer sequences~\cite{oeis}. On instances that could already be solved by
\textsc{ForcLift}, the two algorithms perform equally well. However,
\textsc{Crane} can also solve all but one of the instances that
\textsc{ForcLift} fails on in at most cubic time. See supplementary material for
the exact solutions produced by \textsc{Crane} that correspond to the complexity
results in \cref{tbl:results}. We also note that standard (W)FOMC benchmarks
such as \cref{example:smokers} that are already supported by \textsc{ForcLift}
remain feasible for \textsc{Crane} as well. Moreover, our algorithm can also
handle the linear order axiom, for which a bespoke algorithm was recently
proposed by T{\'{o}}th and
Ku\v{z}elka~\shortcite{DBLP:journals/corr/abs-2211-01164}.

\section{Conclusion and Future Work}\label{sec:conclusion}

In this paper, we showed how a state-of-the-art (W)FOMC algorithm can be
empowered by generalising domain recursion and adding support for cycles in the
graph that encodes a solution. To construct such graphs, \textsc{Crane}
supplements \textsc{ForcLift}~\cite{DBLP:conf/ijcai/BroeckTMDR11} with three
new compilation rules. Our experiments revealed a range of counting problems
that are liftable to \textsc{Crane} but not to any other (W)FOMC algorithm.
Although in this paper we focus on unweighted counting, \textsc{ForcLift}'s
support for weights trivially transfers to \textsc{Crane} as well. The common
thread across these newly liftable problems is (partial) injectivity. Thus, we
can formulate the following conjecture.

\begin{conjecture}
  Let \IFO{} be the class of formulas in FOL that contain clauses with at most
  two variables as well as any number of copies of
  \begin{align*}
    &\begin{multlined}[t]
      (\forall X \in \Gamma\text{. }\forall Y, Z \in \Delta\text{. }\\
      Y \ne Z \Rightarrow \neg \texttt{\textup{p}}(X, Y) \lor \neg \texttt{\textup{p}}(X, Z)) \land
    \end{multlined}\\
    &\begin{multlined}[t]
      (\forall X, Z \in \Gamma\text{. }\forall Y \in \Delta\text{. }\\
      X \ne Z \Rightarrow \neg \texttt{\textup{p}}(X, Y) \lor \neg \texttt{\textup{p}}(Z, Y))
    \end{multlined}
  \end{align*}
  for some predicate $\texttt{\textup{p}}/2$ and domains $\Gamma$ and $\Delta$.
  Then \IFO{} is liftable by \textsc{Crane}.
\end{conjecture}

Recall that \Ctwo{} is the class of formulas with counting quantifiers and at
most two variables. \Ctwo{} was recently shown to be
liftable~\cite{DBLP:journals/jair/Kuzelka21} but without providing a usable
(W)FOMC algorithm. Since the tasks of counting injections and bijections fall
into the \Ctwo{} fragment, we can conjecture the following.

\begin{conjecture}
  \Ctwo{} is liftable by \textsc{Crane} by either reformulating formulas in
  \Ctwo{} to avoid counting quantifiers or extending \textsc{Crane} to support
  them.
\end{conjecture}

However, the most important direction for future work is to fully automate this
new process. First, we need an algorithm that transforms FCGs into definitions
of functions. Formalising this process would also allow us to prove the
correctness of the new compilation rules in constructing FCGs that indeed
compute the right (weighted) model counts. Second, these definitions must be
simplified before they can be used, perhaps by a computer algebra system. Third,
we need a way to find the base cases for the recursive definitions provided by
\textsc{Crane}. Fourth, since the first solution found by \textsc{Crane} is not
always optimal in terms of its complexity, an automated way to determine the
asymptotic complexity of a solution would be helpful as well. Achieving these
goals would enable \textsc{Crane} to automatically constructing efficient ways
to compute various functions and sequences. In addition to the potential impact
on areas of artificial intelligence (AI) such as statistical relational
AI~\cite{DBLP:series/synthesis/2016Raedt}, \textsc{Crane} could be beneficial to
research in combinatorics as well~\cite{DBLP:conf/ilp/BarvinekB0ZK21}.

\bibliographystyle{kr}
\bibliography{paper}

\end{document}
