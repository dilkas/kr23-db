1. Drop the wfomc_cc.py file attached into the FastWFOMC directory

2. Build a custom version of python-flint with the following method added to the fmpz_poly class in fmpz_poly.pyx (we need this for interpolation of polynomials over integers):

    @classmethod
    def interpolate(cls, xs, ys):
        """
        Constructs the unique interpolating polynomial of length at most *n*
        taking the values *ys* when evaluated at the *n* distinct points *xs*.
        """
        cdef fmpz_struct * xsv
        cdef fmpz_struct * ysv
        cdef long n
        xs = [any_as_fmpz(x) for x in xs]
        ys = [any_as_fmpz(y) for y in ys]
        n = len(xs)
        if len(ys) != n:
            raise ValueError("xs and ys must have the same length")
        xsv = <fmpz_struct *> libc.stdlib.malloc(sizeof(fmpz_struct) * n)
        ysv = <fmpz_struct *> libc.stdlib.malloc(sizeof(fmpz_struct) * n)
        for i in range(n):
            xsv[i] = (<fmpz>(xs[i])).val[0]
            ysv[i] = (<fmpz>(ys[i])).val[0]
        u = fmpz_poly.__new__(fmpz_poly)
        fmpz_poly_interpolate_fmpz_vec((<fmpz_poly>u).val, xsv, ysv, n)
        libc.stdlib.free(xsv)
        libc.stdlib.free(ysv)
        return u

3. Use the WFOMCWithCC class in place of the WFOMC class, where the new "ccs" parameter should contain a list of (predicate_name, cardinality) pairs.

You can check it against a simple benchmark on OEIS (e.g. 3-regular graphs) to make sure the numbers look right.

NOTE: I need to manually conver formulas with counting quantifiers into formulas with cardinality constraints
